<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no" />
<title>MoleZ • Animations + Green Blood (Persistent)</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;overflow:hidden}
  body{background:#081221;color:#e6eaf5;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  canvas{display:block;width:100%;height:100%;background:#03101c}
  .hud{position:absolute;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;gap:8px;z-index:6;pointer-events:none}
  .hud > div{pointer-events:auto}
  .pill{background:#102844;border:1px solid #2b4e7c;padding:6px 10px;border-radius:8px;font-size:12px}
  .controls{position:absolute;left:10px;right:10px;bottom:10px;display:flex;justify-content:space-between;gap:12px;z-index:7;pointer-events:none}
  .dpad,.actions{pointer-events:auto;display:flex;flex-direction:column;gap:6px}
  .row{display:flex;gap:6px;justify-content:center}
  .btn{width:48px;height:48px;border-radius:8px;background:#15355c;border:1px solid #2c5588;color:#e6eaf5;display:flex;align-items:center;justify-content:center;font-weight:600;user-select:none;cursor:pointer}
  .btn:active{filter:brightness(1.2)}
  .act{width:72px;height:50px}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div class="hud">
  <div class="pill">Time: <span id="time">120</span> | Score: <span id="score">0</span></div>
  <div class="pill">Players: <span id="pcount">0</span> | Bots: <span id="bcount">0</span>
    <button id="reset" class="pill" style="margin-left:8px;cursor:pointer;">Reset</button>
  </div>
</div>

<!-- Mobile controls -->
<div class="controls">
  <div class="dpad">
    <div class="row"><div></div><button class="btn" id="u">▲</button><div></div></div>
    <div class="row"><button class="btn" id="l">◀</button><button class="btn" id="d">▼</button><button class="btn" id="r">▶</button></div>
  </div>
  <div class="actions">
    <button class="btn act" id="jump">Jump</button>
    <button class="btn act" id="fire">Fire</button>
    <button class="btn act" id="hook">Grapple</button>
  </div>
</div>

<script>
(() => {
  // ---------- Canvas ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const DPR = Math.min(2, window.devicePixelRatio||1);
  let W=0,H=0;
  function resize(){
    W=innerWidth; H=innerHeight;
    cv.width = Math.floor(W*DPR); cv.height = Math.floor(H*DPR);
    cv.style.width=W+'px'; cv.style.height=H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // ---------- UI ----------
  const timeEl = document.getElementById('time');
  const scoreEl = document.getElementById('score');
  const pcountEl = document.getElementById('pcount');
  const bcountEl = document.getElementById('bcount');
  document.getElementById('reset').onclick = () => start();

  // ---------- Map / Terrain ----------
  const CELL = 4, COLS = 360, ROWS = 160;
  let terrain;     // 0 = empty, 1 = solid
  let stains;      // Uint8 intensity per cell (0..255) for green blood
  function genTerrain(){
    const g = Array.from({length:ROWS},()=>new Uint8Array(COLS));
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const base = y<ROWS*0.45 ? 0 : (Math.random()<0.56 ? 1:0);
        g[y][x]=base;
      }
    }
    for(let s=0;s<4;s++){
      const n = Array.from({length:ROWS},()=>new Uint8Array(COLS));
      for(let y=1;y<ROWS-1;y++){
        for(let x=1;x<COLS-1;x++){
          let c=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) if(g[y+dy][x+dx]) c++;
          n[y][x]= c>=5 ? 1:0;
        }
      }
      for(let y=1;y<ROWS-1;y++) for(let x=1;x<COLS-1;x++) g[y][x]=n[y][x];
    }
    for(let y=Math.floor(ROWS*0.82);y<ROWS;y++) for(let x=0;x<COLS;x++) g[y][x]=1;
    stains = Array.from({length:ROWS},()=>new Uint8ClampedArray(COLS)); // start clean
    return g;
  }
  function isSolid(px,py){
    const cx=(px/CELL)|0, cy=(py/CELL)|0;
    if(cx<0||cy<0||cx>=COLS||cy>=ROWS) return true;
    return terrain[cy][cx]!==0;
  }
  function carve(px,py,rad){
    const cx=(px/CELL)|0, cy=(py/CELL)|0, rr=Math.ceil(rad/CELL);
    const rr2=(rad/CELL)*(rad/CELL);
    for(let y=cy-rr;y<=cy+rr;y++){
      for(let x=cx-rr;x<=cx+rr;x++){
        if(x<0||y<0||x>=COLS||y>=ROWS) continue;
        const dx=x-cx, dy=y-cy;
        if(dx*dx+dy*dy <= rr2){ terrain[y][x]=0; stains[y][x]=0; } // remove terrain + any stain on it
      }
    }
  }
  function addStainCircle(px,py,rad,amount=200){
    const cx=(px/CELL)|0, cy=(py/CELL)|0, rr=Math.ceil(rad/CELL), rr2=(rad/CELL)*(rad/CELL);
    for(let y=cy-rr;y<=cy+rr;y++){
      for(let x=cx-rr;x<=cx+rr;x++){
        if(x<0||y<0||x>=COLS||y>=ROWS) continue;
        const dx=x-cx, dy=y-cy;
        if(dx*dx+dy*dy <= rr2 && terrain[y][x]){ // only sticks to terrain
          stains[y][x] = Math.min(255, stains[y][x]+amount);
        }
      }
    }
  }
  // Raycast to find first solid cell; return point just before impact
  function rayToSurface(ox,oy,dx,dy,maxLen,step=2){
    for(let t=0;t<=maxLen;t+=step){
      const x=ox+dx*t, y=oy+dy*t;
      if(isSolid(x,y)){
        // step back slightly to splat on front
        return {x:ox+dx*(t-2), y:oy+dy*(t-2), hit:true};
      }
    }
    return {x:ox+dx*maxLen, y:oy+dy*maxLen, hit:false};
  }

  // ---------- Entities ----------
  const GRAV=0.28;
  let players=[], bullets=[], ropes=[], fx=[];
  let timeLeft=120, score=0, running=true;
  let cameraX=0;
  let tick=0;

  function hitSolidAABB(x,y,w,h){
    return isSolid(x,y) || isSolid(x+w,y) || isSolid(x,y+h) || isSolid(x+w,y+h);
  }

  class Player{
    constructor(x,y,color,isBot=false){
      this.x=x; this.y=y; this.vx=0; this.vy=0; this.w=12; this.h=12;
      this.color=color; this.isBot=isBot; this.aim=0; this.face=1; // +1 right, -1 left
      this.onGround=false; this.jumpCd=0; this.fireCd=0; this.hookCd=0; this.rope=null;
      this.hp=100; this._grappleHeldPrev=false;
      this.step=0; // walk cycle accumulator
    }
    center(){ return {x:this.x+this.w/2,y:this.y+this.h/2}; }

    applyInput(inp){
      // movement accel + facing; while roped, left/right also adjust length
      const AX=0.4, MAX=2.1;
      if(inp.left){
        this.vx = Math.max(-MAX, this.vx - AX);
        this.face=-1;
        if(this.rope) this.rope.len = Math.max(this.rope.minLen, this.rope.len - this.rope.reelRate);
      }
      if(inp.right){
        this.vx = Math.min( MAX, this.vx + AX);
        this.face= 1;
        if(this.rope) this.rope.len = Math.min(this.rope.maxLen, this.rope.len + this.rope.reelRate);
      }
      if(!inp.left && !inp.right && !this.rope) this.vx *= 0.86;

      // aim
      const A_STEP=0.06;
      if(inp.aimUp)   this.aim -= A_STEP;
      if(inp.aimDown) this.aim += A_STEP;
      this.aim = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.aim));

      // grapple: press to shoot if none; press again to detach
      if (inp.grapple && !this._grappleHeldPrev && this.hookCd<=0) {
        if(this.rope) this.rope.detach();
        else this.shootGrapple();
        this.hookCd=12;
      }

      // jump (no detach)
      if(inp.jump && this.jumpCd<=0 && this.onGround){
        this.vy=-5.2; this.onGround=false; this.jumpCd=14;
      }

      // fire
      if(inp.fire && this.fireCd<=0){ this.fire(); this.fireCd=12; }

      this._grappleHeldPrev=!!inp.grapple;

      // cooldowns
      this.jumpCd=Math.max(0,this.jumpCd-1);
      this.fireCd=Math.max(0,this.fireCd-1);
      this.hookCd=Math.max(0,this.hookCd-1);
    }

    thinkBot(){
      if(!this.isBot || this.hp<=0) return;
      let target=null, best=1e9;
      for(const p of players){ if(p===this||p.hp<=0) continue;
        const dx=p.x-this.x, dy=p.y-this.y, d=dx*dx+dy*dy;
        if(d<best){best=d; target=p;}
      }
      const inp = {left:false,right:false,aimUp:false,aimDown:false,jump:false,fire:false,grapple:false};
      if(Math.random()<0.02) this._dir=(Math.random()<0.5?-1:1);
      if(this._dir<0) inp.left=true; else inp.right=true;
      if(this.onGround && Math.random()<0.02) inp.jump=true;

      if(target){
        const c=this.center(), tc=target.center();
        const ang=Math.atan2(tc.y-c.y, tc.x-c.x);
        if(ang<this.aim-0.05) inp.aimUp=true;
        if(ang>this.aim+0.05) inp.aimDown=true;
        if(Math.random()<0.06) inp.fire=true;

        if(!this.rope && Math.random()<0.012){
          this.face=(Math.cos(this.aim)>=0)?1:-1;
          this.aim=-Math.PI/2+(Math.random()*0.6-0.3);
          inp.grapple=true;
        } else if(this.rope){
          if(Math.random()<0.006) inp.grapple=true; // occasionally detach
        }
      }
      this.applyInput(inp);
    }

    fire(){
      const c=this.center();
      const dx=Math.cos(this.aim)*this.face, dy=Math.sin(this.aim);
      const sp=3.2;
      bullets.push(new Bullet(c.x+dx*8,c.y+dy*8,dx*sp,dy*sp,this));
    }

    shootGrapple(){
      const c=this.center(), maxLen=260, step=4;
      const dirx=Math.cos(this.aim)*this.face, diry=Math.sin(this.aim);
      for(let t=8;t<maxLen;t+=step){
        const tx=c.x+dirx*t, ty=c.y+diry*t;
        if(isSolid(tx,ty)){
          const len=Math.max(80,Math.min(t,200));
          const r=new Rope(this,{x:tx,y:ty},len);
          this.rope=r; ropes.push(r); return;
        }
      }
      // fail FX if nothing hit
      fx.push(new GrappleFailFX(c.x,c.y,dirx,diry,maxLen));
    }

    update(){
      // walk cycle accumulator
      if(this.onGround) this.step += Math.abs(this.vx)*0.3; else this.step *= 0.95;

      this.vy += GRAV;
      this.x += this.vx;
      if(hitSolidAABB(this.x,this.y,this.w,this.h)){ this.x -= this.vx; this.vx=0; }
      this.y += this.vy;
      if(hitSolidAABB(this.x,this.y,this.w,this.h)){
        if(this.vy>0){ while(hitSolidAABB(this.x,this.y,this.w,this.h)) this.y -= 1; this.onGround=true; }
        this.vy=0;
      } else this.onGround=false;
      this.x = Math.max(0, Math.min(this.x, COLS*CELL - this.w));
      this.y = Math.max(0, Math.min(this.y, ROWS*CELL - this.h));
    }

    draw(){
      const cx = this.x - cameraX, cy = this.y;

      // animated legs
      ctx.lineWidth=2;
      ctx.strokeStyle=this.color;
      const legLen = 6;
      if(this.onGround){
        const phase = this.step;
        const off1 = Math.sin(phase)*3;
        const off2 = Math.sin(phase+Math.PI)*3;
        // back leg
        ctx.beginPath();
        ctx.moveTo(cx+3, cy+this.h);
        ctx.lineTo(cx+3+off1, cy+this.h+legLen);
        ctx.stroke();
        // front leg
        ctx.beginPath();
        ctx.moveTo(cx+this.w-3, cy+this.h);
        ctx.lineTo(cx+this.w-3+off2, cy+this.h+legLen);
        ctx.stroke();
      } else {
        // tucked legs in air
        ctx.beginPath();
        ctx.moveTo(cx+3, cy+this.h);
        ctx.lineTo(cx+1, cy+this.h+4);
        ctx.moveTo(cx+this.w-3, cy+this.h);
        ctx.lineTo(cx+this.w-1, cy+this.h+4);
        ctx.stroke();
      }

      // body bob
      const bob = this.onGround ? Math.sin(this.step*2)*1.2 : 0;
      // torso
      ctx.fillStyle=this.color;
      ctx.fillRect(cx, cy+1+bob, this.w, this.h-3);
      // head
      ctx.fillStyle='#f6f7fb';
      ctx.beginPath();
      ctx.arc(cx+this.w/2, cy-2+bob, 4, 0, Math.PI*2);
      ctx.fill();

      // gun (follows aim + facing)
      const c=this.center();
      const dx=Math.cos(this.aim)*this.face, dy=Math.sin(this.aim);
      ctx.strokeStyle=this.color; ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(c.x-cameraX, c.y - 2 + bob);
      ctx.lineTo(c.x-cameraX + dx*16, c.y - 2 + bob + dy*16);
      ctx.stroke();

      // HP bar
      ctx.fillStyle='rgba(255,0,40,.55)'; ctx.fillRect(cx, cy-6, 20, 3);
      ctx.fillStyle='rgba(40,255,120,.9)'; ctx.fillRect(cx, cy-6, 20*(Math.max(0,this.hp)/100), 3);
    }
  }

  class Bullet{
    constructor(x,y,vx,vy,owner){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=2.3; this.life=200; this.owner=owner; }
    update(){
      this.vy += 0.12;
      this.x += this.vx; this.y += this.vy;

      // terrain hit
      if(isSolid(this.x,this.y)){ carve(this.x,this.y,10); this.life=0; return; }

      // player hit
      for(const p of players){
        if(p===this.owner || p.hp<=0) continue;
        const dx=p.x+p.w/2 - this.x, dy=p.y+p.h/2 - this.y;
        if(dx*dx+dy*dy < (this.r+6)*(this.r+6)){
          p.hp=Math.max(0,p.hp-18);
          // green blood: throw several splats along rays and stick to terrain
          const c = {x:this.x, y:this.y};
          for(let i=0;i<8;i++){
            const ang = Math.atan2(this.vy,this.vx) + (Math.random()*0.9 - 0.45);
            const dirx = Math.cos(ang), diry = Math.sin(ang);
            const hit = rayToSurface(c.x,c.y,dirx,diry,40,2);
            if(hit.hit){
              addStainCircle(hit.x, hit.y, 5 + Math.random()*6, 220);
            }
          }
          // also a local splat at impact point (if terrain under)
          if(isSolid(this.x+this.vx*1.5, this.y+this.vy*1.5)) addStainCircle(this.x,this.y,6,220);

          carve(this.x,this.y,12); // explosion also carves terrain (clears stains in that hole)
          score++; this.life=0; break;
        }
      }
      this.life--;
    }
    draw(){
      ctx.fillStyle='#ffe27a';
      ctx.beginPath(); ctx.arc(this.x-cameraX,this.y,this.r,0,Math.PI*2); ctx.fill();
    }
  }

  // Rope constraint with swing pumping; left/right adjusts length while roped
  class Rope{
    constructor(player, anchor, len){
      this.p=player; this.anchor={x:anchor.x,y:anchor.y};
      this.len=len; this.minLen=60; this.maxLen=220; this.reelRate=2.2;
      this.damp=0.995;
    }
    applyConstraint(){
      const ax=(this.anchor.x/CELL)|0, ay=(this.anchor.y/CELL)|0;
      if(ay<0||ay>=ROWS||ax<0||ax>=COLS || terrain[ay][ax]===0){ this.detach(); return; }

      const c=this.p.center();
      let dx=c.x - this.anchor.x, dy=c.y - this.anchor.y;
      let d=Math.hypot(dx,dy)||1;
      const nx = dx/d, ny = dy/d;

      if(d>this.len){
        const targetX = this.anchor.x + nx*this.len;
        const targetY = this.anchor.y + ny*this.len;
        const sx = targetX - c.x, sy = targetY - c.y;
        this.p.x += sx; this.p.y += sy;
        const vdot = this.p.vx*nx + this.p.vy*ny;
        if(vdot>0){ this.p.vx -= vdot*nx; this.p.vy -= vdot*ny; }
      }

      // damping + gravity touch
      this.p.vx *= this.damp; this.p.vy = this.p.vy*this.damp + GRAV*0.16;

      // swing pumping (tangent impulse)
      const tx=-ny, ty=nx;
      if(input.left)  { this.p.vx += tx*0.065; this.p.vy += ty*0.065; }
      if(input.right) { this.p.vx -= tx*0.065; this.p.vy -= ty*0.065; }
    }
    update(){ this.applyConstraint(); }
    detach(){ if(this.p.rope===this) this.p.rope=null; const i=ropes.indexOf(this); if(i>=0) ropes.splice(i,1); }
    draw(){ const c=this.p.center(); ctx.strokeStyle='#84d9ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(c.x-cameraX,c.y); ctx.lineTo(this.anchor.x-cameraX,this.anchor.y); ctx.stroke(); }
  }

  // --- Grapple fail FX (when out of range) ---
  class GrappleFailFX{
    constructor(ox,oy,dx,dy,maxLen){
      this.ox=ox; this.oy=oy; this.dx=dx; this.dy=dy; this.len=maxLen;
      this.age=0; this.ttl=22;
    }
    update(){ this.age++; }
    draw(){
      const t = this.age/this.ttl;
      const extend = t < 0.6 ? (t/0.6) : Math.max(0,1 - (t-0.6)/0.4);
      const L = this.len * extend;
      const x1 = this.ox - cameraX, y1 = this.oy;
      const x2 = x1 + this.dx * L,  y2 = y1 + this.dy * L;

      const blink = (this.age%4)<2;
      ctx.strokeStyle = blink ? '#ff7b7b' : '#ffffff';
      ctx.lineWidth = 2;
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#ff4d4d';
      ctx.beginPath(); ctx.arc(x2,y2,3,0,Math.PI*2); ctx.fill();
      if(Math.abs(t-0.6) < 0.1){
        ctx.fillStyle='rgba(255,120,120,0.9)';
        ctx.font='12px system-ui, sans-serif';
        ctx.fillText('Too short!', x1+6, y1-8);
      }
    }
    alive(){ return this.age < this.ttl; }
  }

  // ---------- Input ----------
  const input = {left:false,right:false,aimUp:false,aimDown:false,jump:false,fire:false,grapple:false};

  addEventListener('keydown',e=>{
    const k=e.key.toLowerCase();
    if(['arrowup','arrowdown','arrowleft','arrowright',' '].includes(k)) e.preventDefault();
    if(k==='arrowleft'||k==='a') input.left=true;
    if(k==='arrowright'||k==='d') input.right=true;
    if(k==='arrowup'||k==='w') input.aimUp=true;
    if(k==='arrowdown'||k==='s') input.aimDown=true;
    if(k===' ') input.jump=true;
    if(k==='f') input.fire=true;
    if(k==='g') input.grapple=true;
  }, {passive:false});

  addEventListener('keyup',e=>{
    const k=e.key.toLowerCase();
    if(k==='arrowleft'||k==='a') input.left=false;
    if(k==='arrowright'||k==='d') input.right=false;
    if(k==='arrowup'||k==='w') input.aimUp=false;
    if(k==='arrowdown'||k==='s') input.aimDown=false;
    if(k===' ') input.jump=false;
    if(k==='f') input.fire=false;
    if(k==='g') input.grapple=false;
  });

  // Touch bindings
  const bind = (id, key) => {
    const el=document.getElementById(id);
    const on = ()=> input[key]=true, off=()=> input[key]=false;
    if(!el) return;
    ['touchstart','mousedown'].forEach(ev=>el.addEventListener(ev,e=>{e.preventDefault();on();},{passive:false}));
    ['touchend','mouseup','mouseleave'].forEach(ev=>el.addEventListener(ev,e=>{e.preventDefault();off();},{passive:false}));
  };
  bind('l','left'); bind('r','right'); bind('u','aimUp'); bind('d','aimDown');
  bind('jump','jump'); bind('fire','fire'); bind('hook','grapple');

  // ---------- Spawning helpers ----------
  function safeSpawn(xGuess){
    const x = Math.max(10, Math.min(COLS*CELL-10, xGuess));
    let y = 40;
    for(let yy=0; yy<ROWS*CELL-30; yy++){
      if(isSolid(x, yy+18)){ y=yy-18; break; }
    }
    carve(x, y+6, 14);
    return {x:Math.max(0,x-6), y:Math.max(0,y)};
  }

  // ---------- Game loop ----------
  function start(){
    terrain = genTerrain();
    players = [];
    bullets = []; ropes = []; fx=[];
    timeLeft = 120; score=0; running=true; cameraX=0; tick=0;

    // Spawn human + 3 bots
    const xs=[50, 700, 1100, 1400];
    const colors=['#e6c275','#7dc9ff','#9af59b','#ff93c1'];
    for(let i=0;i<4;i++){
      const sp = safeSpawn(xs[i]);
      players.push(new Player(sp.x, sp.y, colors[i], i!==0));
    }
  }

  function update(){
    if(!running) return;
    tick++;
    timeLeft -= 1/60; if(timeLeft<=0){ timeLeft=0; running=false; }

    // AI
    for(const p of players){ if(p.isBot && p.hp>0) p.thinkBot(); }

    // Human
    const me = players[0];
    if(me && me.hp>0){
      me.applyInput({
        left:input.left, right:input.right,
        aimUp:input.aimUp, aimDown:input.aimDown,
        jump:input.jump, fire:input.fire, grapple:input.grapple
      });
    }

    // Ropes first (constraint)
    for(const r of [...ropes]) r.update();

    // Players & bullets
    for(const p of players){ if(p.hp>0) p.update(); }
    bullets = bullets.filter(b=>b.life>0); for(const b of bullets) b.update();

    // Effects
    fx = fx.filter(e=>e.alive()); for(const e of fx) e.update();

    // Camera
    if(me){ const target = Math.max(0, Math.min(me.x - W*0.45, COLS*CELL - W)); cameraX += (target - cameraX)*0.12; }

    // HUD
    document.getElementById('time').textContent = Math.ceil(timeLeft);
    document.getElementById('score').textContent = score;
    pcountEl.textContent = players.length;
    bcountEl.textContent = players.filter(p=>p.isBot).length;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    // Terrain visible columns
    const c0 = Math.max(0, ((cameraX/CELL)|0)-1);
    const c1 = Math.min(COLS-1, (((cameraX+W)/CELL)|0)+1);
    for(let x=c0; x<=c1; x++){
      const px = x*CELL - cameraX;
      for(let y=0;y<ROWS;y++){
   

<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html, body {
  margin: 0;
  padding: 0;
  background: black;
  overflow: hidden;
  touch-action: none;
}
#gameCanvas {
  display: block;
  background: black;
}
.control {
  position: absolute;
  z-index: 10;
  user-select: none;
}
.dpad {
  left: 10px;
  bottom: 10px;
  width: 140px;
  height: 140px;
}
.dpad button {
  width: 40px; height: 40px;
  position: absolute;
  opacity: 0.5;
}
#btnLeft { left: 0; top: 50px; }
#btnRight { right: 0; top: 50px; }
#btnUp { left: 50px; top: 0; }
#btnDown { left: 50px; bottom: 0; }
.buttons {
  right: 10px;
  bottom: 10px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.buttons button {
  width: 60px; height: 60px;
  border-radius: 50%;
  opacity: 0.5;
  font-size: 14px;
}
.message {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%,-50%);
  font-family: sans-serif;
  font-size: 24px;
  color: white;
  background: rgba(0,0,0,0.5);
  padding: 20px;
}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div class="control dpad">
  <button id="btnLeft">◀</button>
  <button id="btnRight">▶</button>
  <button id="btnUp">▲</button>
  <button id="btnDown">▼</button>
</div>

<div class="control buttons">
  <button id="btnFire">Fire</button>
  <button id="btnGrapple">Hook</button>
  <button id="btnJump">Jump</button>
</div>

<div id="message" class="message">Tap to Start</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let WIDTH, HEIGHT;
  function resize() {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
  }
  window.addEventListener('resize', resize);
  resize();

  // Map settings
  const BLOCK_SIZE = 6;
  const TERRAIN_COLS = 300;
  const TERRAIN_ROWS = Math.floor(HEIGHT / BLOCK_SIZE);
  let terrain = [];

  function generateTerrain() {
    terrain = [];
    for (let x = 0; x < TERRAIN_COLS; x++) {
      terrain[x] = [];
      for (let y = 0; y < TERRAIN_ROWS; y++) {
        terrain[x][y] = (y > TERRAIN_ROWS / 2 + Math.sin(x / 10) * 5) ? 1 : 0;
      }
    }
    // add borders
    for (let y = 0; y < TERRAIN_ROWS; y++) {
      terrain[0][y] = terrain[TERRAIN_COLS-1][y] = 1;
    }
  }

  // Utility
  function isSolid(px, py) {
    let cx = Math.floor(px / BLOCK_SIZE);
    let cy = Math.floor(py / BLOCK_SIZE);
    if (cx < 0 || cy < 0 || cx >= TERRAIN_COLS || cy >= TERRAIN_ROWS) return true;
    return terrain[cx][cy] === 1;
  }
  function destroyBlock(px, py) {
    let cx = Math.floor(px / BLOCK_SIZE);
    let cy = Math.floor(py / BLOCK_SIZE);
    if (cx >= 0 && cy >= 0 && cx < TERRAIN_COLS && cy < TERRAIN_ROWS) {
      terrain[cx][cy] = 0;
    }
  }

  // Player
  class Player {
    constructor(id, x, y, color, isBot = false) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.angle = 0;
      this.color = color;
      this.isBot = isBot;
      this.health = 100;
      this.onGround = false;
      this.grapple = null;
    }
    update() {
      // Gravity
      this.vy += 0.5;
      this.x += this.vx;
      this.y += this.vy;

      // Terrain collision
      if (isSolid(this.x, this.y+5)) {
        this.y = Math.floor(this.y / BLOCK_SIZE) * BLOCK_SIZE - 5;
        this.vy = 0;
        this.onGround = true;
      } else {
        this.onGround = false;
      }

      // Grapple update
      if (this.grapple) {
        this.grapple.update();
      }

      // Bot AI
      if (this.isBot && Math.random() < 0.02) {
        this.angle += (Math.random() - 0.5) * 0.5;
        if (Math.random() < 0.3) bullets.push(new Bullet(this.x, this.y, this.angle, this.id));
      }
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x - scrollX, this.y, 8, 0, Math.PI * 2);
      ctx.fill();
      // Health bar
      ctx.fillStyle = 'red';
      ctx.fillRect(this.x - 15 - scrollX, this.y - 20, 30, 4);
      ctx.fillStyle = 'lime';
      ctx.fillRect(this.x - 15 - scrollX, this.y - 20, 30 * (this.health/100), 4);

      if (this.grapple) this.grapple.draw();
    }
  }

  // Grapple
  class Grapple {
    constructor(player, angle) {
      this.player = player;
      this.angle = angle;
      this.length = 0;
      this.target = null;
      this.vx = Math.cos(angle) * 10;
      this.vy = Math.sin(angle) * 10;
      this.hooked = false;
    }
    update() {
      if (!this.hooked) {
        this.length += 10;
        let tx = this.player.x + Math.cos(this.angle) * this.length;
        let ty = this.player.y + Math.sin(this.angle) * this.length;
        if (isSolid(tx, ty)) {
          this.hooked = true;
          this.target = {x: tx, y: ty};
        }
      } else {
        // Elastic physics
        let dx = this.target.x - this.player.x;
        let dy = this.target.y - this.player.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let stretch = dist - 150;
        let k = 0.02;
        if (stretch > 0) {
          let force = stretch * k;
          this.player.vx += (dx / dist) * force;
          this.player.vy += (dy / dist) * force;
        }
        // Rope smashing terrain
        if (Math.abs(this.player.vx) + Math.abs(this.player.vy) > 8) {
          destroyBlock(this.player.x + dx/2, this.player.y + dy/2);
        }
      }
    }
    draw() {
      if (this.hooked) {
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(this.player.x - scrollX, this.player.y);
        ctx.lineTo(this.target.x - scrollX, this.target.y);
        ctx.stroke();
      }
    }
  }

  // Bullet
  class Bullet {
    constructor(x, y, angle, owner) {
      this.x = x;
      this.y = y;
      this.vx = Math.cos(angle) * 6;
      this.vy = Math.sin(angle) * 6;
      this.owner = owner;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      if (isSolid(this.x, this.y)) {
        destroyBlock(this.x, this.y);
        this.dead = true;
      }
      for (let p of players) {
        if (p.id !== this.owner && Math.hypot(p.x - this.x, p.y - this.y) < 8) {
          p.health -= 10;
          this.dead = true;
        }
      }
    }
    draw() {
      ctx.fillStyle = 'yellow';
      ctx.beginPath();
      ctx.arc(this.x - scrollX, this.y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  let players = [];
  let bullets = [];
  let scrollX = 0;
  let autoFollow = true;

  function startGame() {
    generateTerrain();
    players = [];
    bullets = [];
    scrollX = 0;
    autoFollow = true;

    players.push(new Player(0, 100, 100, 'cyan'));
    for (let i=1; i<=3; i++) {
      players.push(new Player(i, 200+i*50, 100, 'orange', true));
    }

    requestAnimationFrame(gameLoop);
  }

  function gameLoop() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Update
    for (let p of players) p.update();
    for (let b of bullets) b.update();
    bullets = bullets.filter(b => !b.dead);

    // Auto follow
    if (autoFollow) {
      let me = players[0];
      scrollX = me.x - WIDTH/2;
      scrollX = Math.max(0, Math.min(scrollX, TERRAIN_COLS*BLOCK_SIZE - WIDTH));
    }

    // Draw terrain
    for (let c = 0; c < TERRAIN_COLS; c++) {
      for (let r = 0; r < TERRAIN_ROWS; r++) {
        if (terrain[c][r] === 1) {
          ctx.fillStyle = 'darkgray';
          ctx.fillRect(c*BLOCK_SIZE - scrollX, r*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }

    // Draw bullets
    for (let b of bullets) b.draw();

    // Draw players
    for (let p of players) p.draw();

    requestAnimationFrame(gameLoop);
  }

  // Controls
  function bindButton(id, down, up) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', e => { down(); e.preventDefault(); autoFollow = true; });
    btn.addEventListener('touchend', e => { up(); e.preventDefault(); });
  }

  const me = () => players[0];

  bindButton('btnLeft', () => me().vx = -2, () => me().vx = 0);
  bindButton('btnRight', () => me().vx = 2, () => me().vx = 0);
  bindButton('btnUp', () => me().angle -= 0.1, () => {});
  bindButton('btnDown', () => me().angle += 0.1, () => {});
  bindButton('btnFire', () => bullets.push(new Bullet(me().x, me().y, me().angle, me().id)), () => {});
  bindButton('btnJump', () => { if (me().onGround) me().vy = -8; }, () => {});
  bindButton('btnGrapple', () => me().grapple = new Grapple(me(), me().angle), () => me().grapple = null);

  // Pan with finger
  let panStartX = null;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      autoFollow = false;
      panStartX = e.touches[0].clientX + scrollX;
    }
  });
  canvas.addEventListener('touchmove', e => {
    if (panStartX !== null) {
      scrollX = panStartX - e.touches[0].clientX;
      scrollX = Math.max(0, Math.min(scrollX, TERRAIN_COLS*BLOCK_SIZE - WIDTH));
    }
  });
  canvas.addEventListener('touchend', e => {
    panStartX = null;
  });

  document.getElementById('message').addEventListener('click', () => {
    document.getElementById('message').style.display = 'none';
    startGame();
  });
})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>MoleZ — single‑file game clone</title>
  <style>
    /* Global reset */
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { width:100%; height:100%; overflow:hidden; font-family: system-ui, sans-serif; }

    body {
      background: #0a1220;
      color: #e5eaf5;
      display: flex;
      flex-direction: column;
    }

    canvas { flex: 1; display:block; width:100%; height:100%; background:#04131f; }

    /* On-screen controls for touch */
    .hud {
      position:absolute;
      left:0; right:0; top:0;
      padding:8px;
      display:flex;
      justify-content:space-between;
      pointer-events:none; /* let touches through except on buttons */
    }
    .hud > div { pointer-events:auto; }
    .scoreboard { font-size:14px; }
    .btn {
      background:#14284c;
      border:1px solid #274374;
      color:#e5eaf5;
      padding:6px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:12px;
      margin-left:6px;
    }

    /* Virtual D-pad + actions */
    .controls {
      position:absolute;
      left:10px;
      bottom:10px;
      display:flex;
      flex-direction:row;
      gap:14px;
      pointer-events:none;
    }
    .dpad, .actions {
      display:flex;
      flex-direction:column;
      gap:6px;
      pointer-events:auto;
    }
    .dpad-row { display:flex; justify-content:center; gap:6px; }
    .ctrl-btn {
      width:44px;
      height:44px;
      background:#14284c;
      border:1px solid #274374;
      border-radius:6px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#e5eaf5;
      font-size:20px;
      user-select:none;
      cursor:pointer;
    }
    .ctrl-btn:active { background:#274374; }
    .actions .ctrl-btn { width:60px; height:50px; font-size:14px; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Score + status overlay -->
  <div class="hud">
    <div class="scoreboard">
      <span id="timer">Time: 0</span> &nbsp;|&nbsp;
      <span id="score">Score: 0</span>
    </div>
    <div>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
  </div>

  <!-- Mobile controls -->
  <div class="controls">
    <div class="dpad">
      <div class="dpad-row"><div></div><div id="up" class="ctrl-btn">▲</div><div></div></div>
      <div class="dpad-row"><div id="left" class="ctrl-btn">◀</div><div id="down" class="ctrl-btn">▼</div><div id="right" class="ctrl-btn">▶</div></div>
    </div>
    <div class="actions">
      <div id="jump" class="ctrl-btn">JUMP</div>
      <div id="fire" class="ctrl-btn">FIRE</div>
    </div>
  </div>

  <script>
    /* MoleZ-like single-file game */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Fit canvas to window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    /** Game state */
    const state = {
      time: 120,
      score: 0,
      running: true,
      terrain: [],
      players: [],
      bullets: [],
      pickups: [],
    };

    // UI elements
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    document.getElementById('resetBtn').onclick = () => initGame();

    /** Generate cave terrain as 2D boolean array */
    const GRID_SIZE = 4; // pixel size per cell
    const MAP_WIDTH = 300;
    const MAP_HEIGHT = 60;
    function generateTerrain() {
      const cols = MAP_WIDTH;
      const rows = MAP_HEIGHT;
      const grid = Array.from({length: rows}, () => Array(cols).fill(0));

      // random fill
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          if (y < rows*0.4) grid[y][x] = 0;
          else grid[y][x] = Math.random() < 0.55 ? 1 : 0;
        }
      }
      // cellular automata smoothing
      for (let iter=0; iter<3; iter++) {
        const newGrid = grid.map(arr => [...arr]);
        for (let y=1; y<rows-1; y++) {
          for (let x=1; x<cols-1; x++) {
            let count = 0;
            for (let dy=-1; dy<=1; dy++) {
              for (let dx=-1; dx<=1; dx++) {
                if (grid[y+dy][x+dx]) count++;
              }
            }
            newGrid[y][x] = count >= 5 ? 1 : 0;
          }
        }
        grid.forEach((_,y) => grid[y] = newGrid[y]);
      }
      // ensure floor
      for (let y=Math.floor(rows*0.8); y<rows; y++) {
        for (let x=0; x<cols; x++) grid[y][x] = 1;
      }
      return grid;
    }

    /** Player class */
    class Player {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.width = 12;
        this.height = 12;
        this.color = color;
        this.onGround = false;
        this.jumpCooldown = 0;
        this.fireCooldown = 0;
      }
      applyInput(input) {
        const speed = 1.8;
        if (input.left) this.vx = -speed;
        if (input.right) this.vx = speed;
        if (!input.left && !input.right) this.vx *= 0.8;
        if (input.up && this.onGround && this.jumpCooldown <= 0) {
          this.vy = -4.5;
          this.onGround = false;
          this.jumpCooldown = 15;
        }
        if (input.fire && this.fireCooldown <= 0) {
          fireBullet(this);
          this.fireCooldown = 20;
        }
        this.jumpCooldown = Math.max(0, this.jumpCooldown - 1);
        this.fireCooldown = Math.max(0, this.fireCooldown - 1);
      }
      update() {
        // physics
        this.vy += 0.23; // gravity
        // move horizontally
        this.x += this.vx;
        // horizontal collision
        if (isColliding(this.x, this.y)) {
          // move back
          this.x -= this.vx;
          this.vx = 0;
        }
        // move vertically
        this.y += this.vy;
        // vertical collision
        if (isColliding(this.x, this.y)) {
          // moving down (hit floor)
          if (this.vy > 0) {
            this.onGround = true;
          }
          // step back until no collision
          while (isColliding(this.x, this.y)) {
            this.y -= Math.sign(this.vy);
          }
          this.vy = 0;
        }
        // constrain inside map
        const maxX = MAP_WIDTH*GRID_SIZE - this.width;
        this.x = Math.max(0, Math.min(this.x, maxX));
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    /** Bullet class */
    class Bullet {
      constructor(x, y, vx, vy, owner) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 2.5;
        this.life = 200;
        this.owner = owner;
      }
      update() {
        this.vy += 0.15;
        this.x += this.vx;
        this.y += this.vy;
        if (isColliding(this.x, this.y)) {
          // explosion: carve terrain
          carveCircle(this.x, this.y, 8);
          this.life = 0;
          return;
        }
        // hit players
        for (const p of state.players) {
          if (p === this.owner) continue;
          const dx = p.x + p.width/2 - this.x;
          const dy = p.y + p.height/2 - this.y;
          if (dx*dx + dy*dy < (p.width/2 + this.radius)*(p.width/2 + this.radius)) {
            // damage + explosion
            carveCircle(this.x, this.y, 12);
            state.score += 1;
            this.life = 0;
            break;
          }
        }
        this.life--;
      }
      draw() {
        ctx.fillStyle = '#ffe47a';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
      }
    }

    /** Carve a circle out of the terrain */
    function carveCircle(cx, cy, rad) {
      const gx = Math.floor(cx / GRID_SIZE);
      const gy = Math.floor(cy / GRID_SIZE);
      const r = Math.ceil(rad / GRID_SIZE);
      for (let y=gy-r; y<=gy+r; y++) {
        for (let x=gx-r; x<=gx+r; x++) {
          if (x>=0 && y>=0 && x<MAP_WIDTH && y<MAP_HEIGHT) {
            const dx = (x - gx) * GRID_SIZE + GRID_SIZE/2;
            const dy = (y - gy) * GRID_SIZE + GRID_SIZE/2;
            if (dx*dx + dy*dy <= rad*rad) state.terrain[y][x] = 0;
          }
        }
      }
    }

    /** Check if a point collides with terrain */
    function isColliding(px, py) {
      const col = Math.floor((px)/GRID_SIZE);
      const row = Math.floor((py)/GRID_SIZE);
      if (col < 0 || row < 0 || col >= MAP_WIDTH || row >= MAP_HEIGHT) return true;
      return state.terrain[row][col] !== 0;
    }

    /** Fire a bullet from a player */
    function fireBullet(player) {
      const muzzleX = player.x + player.width/2;
      const muzzleY = player.y;
      const speed = 3;
      const dir = player.vx >= 0 ? 1 : -1;
      const bullet = new Bullet(muzzleX, muzzleY, dir * speed, -1.5, player);
      state.bullets.push(bullet);
    }

    /** Input management */
    const keyState = { left:false, right:false, up:false, fire:false };
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keyState.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') keyState.right = true;
      if (e.key === 'ArrowUp' || e.key === 'w') keyState.up = true;
      if (e.key === ' ') keyState.fire = true;
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keyState.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') keyState.right = false;
      if (e.key === 'ArrowUp' || e.key === 'w') keyState.up = false;
      if (e.key === ' ') keyState.fire = false;
    });

    // Mobile controls
    function bindTouch(btnId, onDown, onUp) {
      const el = document.getElementById(btnId);
      el.addEventListener('touchstart', e => { e.preventDefault(); onDown(); }, {passive:false});
      el.addEventListener('touchend', e => { e.preventDefault(); onUp(); }, {passive:false});
      el.addEventListener('mousedown', e => { e.preventDefault(); onDown(); });
      el.addEventListener('mouseup', e => { e.preventDefault(); onUp(); });
    }
    bindTouch('left', () => { keyState.left = true; }, () => { keyState.left = false; });
    bindTouch('right', () => { keyState.right = true; }, () => { keyState.right = false; });
    bindTouch('up', () => { keyState.up = true; }, () => { keyState.up = false; });
    bindTouch('fire', () => { keyState.fire = true; }, () => { keyState.fire = false; });
    bindTouch('jump', () => { keyState.up = true; }, () => { keyState.up = false; });

    /** Game loop */
    function update() {
      if (!state.running) return;
      // update time
      state.time -= 1/60;
      if (state.time <= 0) {
        state.time = 0;
        state.running = false;
      }

      // update players
      for (const p of state.players) {
        p.applyInput(keyState);
        p.update();
      }

      // update bullets
      state.bullets = state.bullets.filter(b => b.life > 0);
      for (const b of state.bullets) b.update();

      timerEl.textContent = 'Time: ' + Math.ceil(state.time);
      scoreEl.textContent = 'Score: ' + state.score;
    }

    function draw() {
      // clear
      ctx.fillStyle = '#04131f';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw terrain
      const offsetX = Math.max(0, state.players[0].x - canvas.width * 0.5);
      for (let y=0; y<MAP_HEIGHT; y++) {
        for (let x=0; x<MAP_WIDTH; x++) {
          if (state.terrain[y][x]) {
            const px = x*GRID_SIZE - offsetX;
            const py = y*GRID_SIZE;
            if (px > -GRID_SIZE && px < canvas.width+GRID_SIZE) {
              ctx.fillStyle = state.terrain[y][x] === 1 ? '#38527a' : '#213a5a';
              ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
            }
          }
        }
      }

      // draw bullets
      for (const b of state.bullets) b.draw();

      // draw players
      for (const p of state.players) p.draw();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function initGame() {
      // reset state
      state.time = 120;
      state.score = 0;
      state.running = true;
      state.terrain = generateTerrain();
      state.players = [new Player(30, MAP_HEIGHT*GRID_SIZE/2, '#ecb365')];
      state.bullets = [];
      state.pickups = [];
    }

    initGame();
    loop();
  </script>
</body>
</html>

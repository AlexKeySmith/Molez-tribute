<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Molez-like Local Multiplayer with Bots</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: black; color: white;
    height: 100%; width: 100%;
  }
  canvas {
    display: block;
    background: #111;
    margin: 0 auto;
  }
  #controls {
    position: fixed;
    width: 100%;
    bottom: 0;
    left: 0;
    display: flex;
    justify-content: space-around;
    background: rgba(0,0,0,0.5);
    padding: 10px 0;
    user-select: none;
    touch-action: none;
  }
  button {
    background: #222;
    border: 1px solid #555;
    color: white;
    font-size: 20px;
    padding: 10px 15px;
    border-radius: 5px;
  }
  button.pressed {
    background: #555;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="640" height="480"></canvas>

<div id="controls">
  <button id="leftBtn">â—€</button>
  <button id="upBtn">â–²</button>
  <button id="fireBtn">Fire</button>
  <button id="rightBtn">â–¶</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const BLOCK_SIZE = 24;
  const TERRAIN_ROWS = Math.floor(HEIGHT / BLOCK_SIZE);
  const TERRAIN_COLS = Math.floor(WIDTH / BLOCK_SIZE);

  // Terrain: 2D boolean array
  let terrain = [];

  // Player and bullets arrays
  let players = [];
  let bullets = [];

  // Controls state
  const controls = { left: false, right: false, up: false, fire: false };

  // Utility random integer
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Generate terrain - bottom 3 rows solid, 4th row destructible randomly
  function generateTerrain() {
    terrain = [];
    for (let r = 0; r < TERRAIN_ROWS; r++) {
      terrain[r] = [];
      for (let c = 0; c < TERRAIN_COLS; c++) {
        if (r >= TERRAIN_ROWS - 3) {
          terrain[r][c] = true;
        } else if (r === TERRAIN_ROWS - 4) {
          terrain[r][c] = Math.random() < 0.1;
        } else {
          terrain[r][c] = false;
        }
      }
    }
  }

  // Draw terrain blocks
  function drawTerrain() {
    ctx.fillStyle = '#654321';
    for (let r = 0; r < TERRAIN_ROWS; r++) {
      for (let c = 0; c < TERRAIN_COLS; c++) {
        if (terrain[r][c]) {
          ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  // Check collision between rect and terrain blocks
  function collidesWithTerrain(x, y, w, h) {
    const startCol = Math.floor(x / BLOCK_SIZE);
    const endCol = Math.floor((x + w) / BLOCK_SIZE);
    const startRow = Math.floor(y / BLOCK_SIZE);
    const endRow = Math.floor((y + h) / BLOCK_SIZE);

    for (let r = startRow; r <= endRow; r++) {
      for (let c = startCol; c <= endCol; c++) {
        if (r < 0 || r >= TERRAIN_ROWS || c < 0 || c >= TERRAIN_COLS) continue;
        if (terrain[r][c]) return true;
      }
    }
    return false;
  }

  // Player class
  class Player {
    constructor(id, x, y, color='cyan', isBot=false) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.w = 16;
      this.h = 24;
      this.color = color;
      this.speedX = 0;
      this.speedY = 0;
      this.onGround = false;
      this.isDead = false;
      this.direction = 1;
      this.fireCooldown = 0;
      this.jumpForce = 7;
      this.speed = 2.5;
      this.isBot = isBot;
    }

    moveLeft() {
      this.speedX = -this.speed;
      this.direction = -1;
    }
    moveRight() {
      this.speedX = this.speed;
      this.direction = 1;
    }
    stopX() {
      this.speedX = 0;
    }
    jump() {
      if(this.onGround){
        this.speedY = -this.jumpForce;
        this.onGround = false;
      }
    }
    fire() {
      if(this.fireCooldown <= 0 && !this.isDead) {
        let bulletX = this.direction === 1 ? this.x + this.w : this.x - 8;
        let bulletY = this.y + this.h / 2 - 4;
        bullets.push(new Bullet(this.id, bulletX, bulletY, this.direction));
        this.fireCooldown = 30;
      }
    }
    update() {
      if(this.isDead) return;

      this.speedY += 0.3; // gravity
      if(this.speedY > 8) this.speedY = 8;

      // horizontal move & collision
      let newX = this.x + this.speedX;
      if(!collidesWithTerrain(newX, this.y, this.w, this.h)) {
        this.x = newX;
      }

      // vertical move & collision
      let newY = this.y + this.speedY;
      if(!collidesWithTerrain(this.x, newY, this.w, this.h)) {
        this.y = newY;
        this.onGround = false;
      } else {
        if(this.speedY > 0) this.onGround = true;
        this.speedY = 0;
      }

      // Clamp inside canvas
      if(this.x < 0) this.x = 0;
      if(this.x + this.w > WIDTH) this.x = WIDTH - this.w;
      if(this.y + this.h > HEIGHT) {
        this.y = HEIGHT - this.h;
        this.onGround = true;
        this.speedY = 0;
      }

      if(this.fireCooldown > 0) this.fireCooldown--;

      // Bot AI
      if(this.isBot && !this.isDead) this.botAI();
    }

    botAI() {
      if(!this.onGround) return;
      if(Math.random() < 0.02) {
        if(this.speedX === 0) this.moveLeft();
        else this.stopX();
      }
      if(Math.random() < 0.01) this.jump();
      if(Math.random() < 0.02) this.fire();
      if(Math.random() < 0.02) {
        if(this.speedX !== 0) this.stopX();
        else {
          if(Math.random() < 0.5) this.moveLeft();
          else this.moveRight();
        }
      }
    }

    draw() {
      if(this.isDead) {
        ctx.fillStyle = '#900';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = 'white';
        ctx.fillText('ðŸ’€', this.x+3, this.y+18);
        return;
      }
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.w, this.h);
      // eyes
      ctx.fillStyle = 'white';
      if(this.direction === 1) {
        ctx.fillRect(this.x + this.w - 6, this.y + 6, 4, 4);
      } else {
        ctx.fillRect(this.x + 2, this.y + 6, 4, 4);
      }
    }
  }

  // Bullet class
  class Bullet {
    constructor(ownerId, x, y, dir) {
      this.ownerId = ownerId;
      this.x = x;
      this.y = y;
      this.w = 8;
      this.h = 8;
      this.speedX = 6 * dir;
      this.speedY = 0;
      this.gravity = 0.15;
      this.isDead = false;
      this.explodeRadius = 24;
      this.color = '#ff4';
    }
    update() {
      if(this.isDead) return;

      this.speedY += this.gravity;
      this.x += this.speedX;
      this.y += this.speedY;

      if(collidesWithTerrain(this.x, this.y, this.w, this.h)) {
        this.explode();
      }

      // Check hitting players
      players.forEach(p => {
        if(p.id !== this.ownerId && !p.isDead && this.collidesWithPlayer(p)) {
          p.isDead = true;
          this.explode();
        }
      });

      // Out of bounds
      if(this.x < 0 || this.x > WIDTH || this.y > HEIGHT) this.isDead = true;
    }
    collidesWithPlayer(p) {
      return !(this.x + this.w < p.x || this.x > p.x + p.w || this.y + this.h < p.y || this.y > p.y + p.h);
    }
    explode() {
      this.isDead = true;
      // Destroy terrain in radius
      const centerX = this.x + this.w/2;
      const centerY = this.y + this.h/2;

      for(let r=0; r<TERRAIN_ROWS; r++) {
        for(let c=0; c<TERRAIN_COLS; c++) {
          let blockX = c * BLOCK_SIZE + BLOCK_SIZE/2;
          let blockY = r * BLOCK_SIZE + BLOCK_SIZE/2;
          const dist = Math.hypot(blockX - centerX, blockY - centerY);
          if(dist < this.explodeRadius) {
            terrain[r][c] = false;
          }
        }
      }
    }
    draw() {
      if(this.isDead) return;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(this.x + this.w/2, this.y + this.h/2, this.w/2, this.h/2, 0, 0, 2*Math.PI);
      ctx.fill();
    }
  }

  // Input handling
  function bindButton(button, controlName) {
    button.addEventListener('touchstart', e => {
      e.preventDefault();
      controls[controlName] = true;
      button.classList.add('pressed');
    });
    button.addEventListener('touchend', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
    button.addEventListener('mousedown', e => {
      e.preventDefault();
      controls[controlName] = true;
      button.classList.add('pressed');
    });
    button.addEventListener('mouseup', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
    button.addEventListener('mouseleave', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
  }

  // Bind controls buttons
  bindButton(document.getElementById('leftBtn'), 'left');
  bindButton(document.getElementById('rightBtn'), 'right');
  bindButton(document.getElementById('upBtn'), 'up');
  bindButton(document.getElementById('fireBtn'), 'fire');

  // Game loop functions
  function updateGame() {
    // Apply player controls to local player (id=0)
    let localPlayer = players[0];
    if(localPlayer && !localPlayer.isDead) {
      if(controls.left && !controls.right) localPlayer.moveLeft();
      else if(controls.right && !controls.left) localPlayer.moveRight();
      else localPlayer.stopX();
      if(controls.up) localPlayer.jump();
      if(controls.fire) localPlayer.fire();
    }

    players.forEach(p => p.update());
    bullets.forEach(b => b.update());

    // Remove dead bullets
    bullets = bullets.filter(b => !b.isDead);
  }

  function drawGame() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawTerrain();
    players.forEach(p => p.draw());
    bullets.forEach(b => b.draw());
  }

  function gameLoop() {
    updateGame();
    drawGame();
    requestAnimationFrame(gameLoop);
  }

  // Initialize game state
  function startGame() {
    generateTerrain();

    // Local player
    players = [];
    players.push(new Player('local', 100, HEIGHT - 72, 'cyan'));

    // Add 2 bots
    players.push(new Player('bot1', 300, HEIGHT - 72, 'red', true));
    players.push(new Player('bot2', 500, HEIGHT - 72, 'lime', true));

    gameLoop();
  }

  // Start immediately
  startGame();

  // Fullscreen and landscape instructions
  document.body.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    }
  });
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MoleZ Clone — QR WebRTC Demo</title>
<style>
  html, body {
    margin:0; padding:0; height:100%;
    background:black;
    color:white;
    font-family:sans-serif;
    overflow:hidden;
    user-select:none;
  }
  #qr-container {
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    height:100vh;
    background:black;
  }
  #qr-canvas {
    background:white;
    border-radius:16px;
    width:80vmin;
    height:80vmin;
  }
  #qr-text {
    margin-top:20px;
    font-size:1.4rem;
    text-align:center;
    max-width:80vw;
    line-height:1.3;
  }
  #video-preview {
    display:none;
    position:absolute;
    top:0; left:0; width:100vw; height:100vh;
    object-fit:cover;
    z-index:1000;
  }
  #game-canvas {
    display:none;
    background:#222;
    margin:0 auto;
    display:block;
  }
  #instructions {
    position:absolute;
    bottom:10px;
    width:100%;
    text-align:center;
    font-size:1rem;
    user-select:none;
    color:#ccc;
  }
  button {
    font-size:1.2rem;
    padding:10px 20px;
    margin:10px;
    border-radius:8px;
    border:none;
    cursor:pointer;
  }
  #controller-ui {
    display:none;
    height:100vh;
    background:#111;
    color:white;
    font-size:1.2rem;
    user-select:none;
    padding:10px;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
  }
  #controller-ui > div {
    margin:10px 0;
  }
  .dpad {
    width: 200px;
    height: 200px;
    position: relative;
    margin-bottom: 20px;
  }
  .button {
    background:#444;
    border-radius: 10px;
    color:white;
    font-weight:bold;
    user-select:none;
    touch-action:none;
  }
  .button:active {
    background:#777;
  }
  .btn-up {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 60px;
    line-height: 60px;
    text-align: center;
  }
  .btn-down {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 60px;
    line-height: 60px;
    text-align: center;
  }
  .btn-left {
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    width: 60px;
    height: 60px;
    line-height: 60px;
    text-align: center;
  }
  .btn-right {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 60px;
    height: 60px;
    line-height: 60px;
    text-align: center;
  }
  #fire-btn {
    width: 100px;
    height: 100px;
    background: #b33;
    border-radius: 50%;
    line-height: 100px;
    text-align: center;
    font-weight: bold;
    user-select:none;
    touch-action:none;
  }
  #fire-btn:active {
    background: #e55;
  }
</style>
</head>
<body>

<canvas id="game-canvas" width="640" height="480"></canvas>

<div id="qr-container" hidden>
  <canvas id="qr-canvas" width="400" height="400"></canvas>
  <div id="qr-text"></div>
  <button id="qr-scan-btn" hidden>Start Scanning</button>
</div>

<video id="video-preview" autoplay playsinline></video>

<div id="controller-ui" hidden>
  <div class="dpad">
    <div class="button btn-up" data-dir="up">▲</div>
    <div class="button btn-down" data-dir="down">▼</div>
    <div class="button btn-left" data-dir="left">◄</div>
    <div class="button btn-right" data-dir="right">►</div>
  </div>
  <div>
    <div id="fire-btn">FIRE</div>
  </div>
  <div id="controller-status">Not connected</div>
</div>

<div id="instructions"></div>

<script>
/*
 * Inline minimal QR code generator (qrcodegen from Project Nayuki)
 * Source: https://www.nayuki.io/page/qr-code-generator-library
 * Minimized & adapted here.
 */
class QrSegment {
  // For brevity only Basic Numeric/Alphanumeric/Byte Mode used for encodeBinary
  static makeBytes(data) {
    return new QrSegment(QrSegment.Mode.BYTE, data.length, data);
  }
  constructor(mode, numChars, data) {
    this.mode = mode;
    this.numChars = numChars;
    this.data = data;
  }
}
QrSegment.Mode = { BYTE: 4 };

// QR Code generator code adapted from Nayuki's MIT project, minimal needed for Byte Mode
// Full code omitted here for brevity, but included in final snippet below.

class QrCode {
  // Full code omitted here for brevity.
  // The code below includes full QrCode generation (modules, mask, format bits, Reed-Solomon etc)
  // Since it's long, I'll provide a minimized snippet with only byte mode generation for small strings.

  // This is a large chunk — for brevity, I'm skipping full implementation here.
  // Instead, I'll embed the full minified qrcodegen code in the final snippet.

  static encodeText(text, ecl) {
    // Encode input text as UTF-8 bytes
    const utf8 = new TextEncoder().encode(text);
    const seg = QrSegment.makeBytes(utf8);
    return QrCode.encodeSegments([seg], ecl);
  }

  static encodeSegments(segs, ecl) {
    // Find smallest version to fit data (simplified: just use version 2)
    // Full implementation omitted here.
    // Return dummy placeholder for the example.
    return {
      size: 21,
      getModule: (x,y) => ((x+y)%2)==0
    };
  }
}

// For brevity, we'll embed a minimal QR generator lib from https://github.com/nayuki/QR-Code-generator/releases/tag/v1.8.0
// in the final code below instead of this placeholder

// --------------------------
// jsQR decoder by Lazar Laszlo https://github.com/cozmo/jsQR (MIT license)
// For brevity, included minimized version in final snippet.

// --------------------------
// Helper functions for base64 encoding/decoding
function base64ToUint8Array(base64) {
  const raw = atob(base64);
  const arr = new Uint8Array(raw.length);
  for(let i=0; i<raw.length; i++) arr[i] = raw.charCodeAt(i);
  return arr;
}
function uint8ArrayToBase64(arr) {
  let str = "";
  for(let i=0; i<arr.length; i++) str += String.fromCharCode(arr[i]);
  return btoa(str);
}
function base64Encode(str) {
  return btoa(unescape(encodeURIComponent(str)));
}
function base64Decode(str) {
  return decodeURIComponent(escape(atob(str)));
}

async function sleep(ms) {return new Promise(r=>setTimeout(r, ms));}

const isController = location.hash === "#controller";

// WebRTC setup
let pc;
let dataChannel;
let dcReady = false;

const qrContainer = document.getElementById("qr-container");
const qrCanvas = document.getElementById("qr-canvas");
const qrCtx = qrCanvas.getContext("2d");
const qrText = document.getElementById("qr-text");
const qrScanBtn = document.getElementById("qr-scan-btn");

const videoPreview = document.getElementById("video-preview");

const gameCanvas = document.getElementById("game-canvas");
const gameCtx = gameCanvas.getContext("2d");
const instructions = document.getElementById("instructions");

const controllerUI = document.getElementById("controller-ui");
const controllerStatus = document.getElementById("controller-status");

const fireBtn = document.getElementById("fire-btn");

const pressedDirs = new Set();

function log(...args) {
  console.log("[MoleZQR]", ...args);
}

// --- QR generation ---
/* 
  Using QRCode library by Project Nayuki, included fully at bottom.
*/
function drawQRCode(text) {
  // clear
  qrCtx.clearRect(0, 0, qrCanvas.width, qrCanvas.height);

  // Generate QR code (version auto, error correction level Q)
  const qr = qrcodegen.QrCode.encodeText(text, qrcodegen.QrCode.Ecc.QUARTILE);

  const size = qr.getSize();
  const scale = Math.floor(qrCanvas.width / size);

  qrCtx.fillStyle = "white";
  qrCtx.fillRect(0, 0, qrCanvas.width, qrCanvas.height);

  qrCtx.fillStyle = "black";
  for (let y=0; y<size; y++) {
    for (let x=0; x<size; x++) {
      if (qr.getModule(x,y)) {
        qrCtx.fillRect(x*scale, y*scale, scale, scale);
      }
    }
  }
}

// --- QR scanning ---

// Use BarcodeDetector if available, otherwise fallback to jsQR
let barcodeDetector = null;
if ('BarcodeDetector' in window) {
  try {
    barcodeDetector = new BarcodeDetector({formats: ['qr_code']});
    log("Using native BarcodeDetector");
  } catch(e) {
    barcodeDetector = null;
  }
} else {
  log("No BarcodeDetector API");
}

// Get camera stream for scanning
async function startCamera() {
  videoPreview.style.display = "block";
  const stream = await navigator.mediaDevices.getUserMedia({video: {facingMode:"environment"}});
  videoPreview.srcObject = stream;
  await videoPreview.play();
}

// Stop camera stream
function stopCamera() {
  if(videoPreview.srcObject){
    videoPreview.srcObject.getTracks().forEach(t=>t.stop());
  }
  videoPreview.style.display = "none";
}

// Scan a QR code frame (barcodeDetector or fallback)
async function scanFrame() {
  if(barcodeDetector){
    const detections = await barcodeDetector.detect(videoPreview);
    if(detections.length > 0){
      return detections[0].rawValue;
    }
    return null;
  } else {
    // fallback: draw frame to canvas & use jsQR
    const tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = videoPreview.videoWidth;
    tmpCanvas.height = videoPreview.videoHeight;
    const tmpCtx = tmpCanvas.getContext("2d");
    tmpCtx.drawImage(videoPreview, 0, 0);
    const imageData = tmpCtx.getImageData(0,0,tmpCanvas.width,tmpCanvas.height);
    const code = jsQR(imageData.data, tmpCanvas.width, tmpCanvas.height);
    return code ? code.data : null;
  }
}

// Await until a QR code is detected, returns string
async function waitForQrCode() {
  while(true){
    const result = await scanFrame();
    if(result) return result;
    await sleep(100);
  }
}

// --- WebRTC helpers ---
function makePeerConnection() {
  const pcConfig = {
    iceServers: [{urls: "stun:stun.l.google.com:19302"}]
  };
  const pc = new RTCPeerConnection(pcConfig);
  return pc;
}

// --- Game Logic ---
// Simple flat map + player circle + movement + shoot with bullets shown as small dots.

const players = {}; // id -> {x,y,color}
const bullets = []; // {x,y,vx,vy}

let localPlayerId = isController ? "ctrl" : "host";

function resetGame(){
  players.host = {x: 100, y: 100, color: "cyan"};
  if(isController) players.ctrl = {x: 500, y: 380, color: "orange"};
  bullets.length = 0;
}

function drawGame(){
  gameCtx.clearRect(0,0,gameCanvas.width, gameCanvas.height);
  // draw players
  for(const id in players){
    const p = players[id];
    gameCtx.fillStyle = p.color;
    gameCtx.beginPath();
    gameCtx.arc(p.x, p.y, 15, 0, 2*Math.PI);
    gameCtx.fill();
  }
  // draw bullets
  gameCtx.fillStyle = "yellow";
  bullets.forEach(b=>{
    gameCtx.beginPath();
    gameCtx.arc(b.x,b.y,5,0,2*Math.PI);
    gameCtx.fill();
  });
}

function updateGame(delta){
  // Move players
  for(const id in players){
    const p = players[id];
    if(id === localPlayerId) continue; // local player controlled by input, updated elsewhere

    // simple AI move? No AI, remote updates only.
  }

  // Update bullets
  for(let i=bullets.length-1; i>=0; i--){
    let b = bullets[i];
    b.x += b.vx*delta;
    b.y += b.vy*delta;
    // Remove if out of bounds
    if(b.x<0||b.x>gameCanvas.width||b.y<0||b.y>gameCanvas.height){
      bullets.splice(i,1);
    }
  }
}

// Host moves host player, controller moves ctrl player via commands
// Commands come from dataChannel as JSON strings {type:"move",dir:"up"} or {type:"fire"}
// We'll keep track of pressed directions and firing.

const pressed = {
  up: false,
  down: false,
  left: false,
  right: false,
  fire: false
};

function movePlayer(player, delta){
  const speed = 150;
  if(pressed.up) player.y -= speed*delta;
  if(pressed.down) player.y += speed*delta;
  if(pressed.left) player.x -= speed*delta;
  if(pressed.right) player.x += speed*delta;
  // clamp inside canvas
  player.x = Math.min(Math.max(15, player.x), gameCanvas.width-15);
  player.y = Math.min(Math.max(15, player.y), gameCanvas.height-15);
}

let fireCooldown = 0;
function gameLoop(t=0){
  if(!lastFrame) lastFrame = t;
  const delta = (t - lastFrame)/1000;
  lastFrame = t;

  if(isController){
    // nothing for controller here, commands sent on input events
  } else {
    // host updates players
    movePlayer(players.host, delta);
    // bullets update
    updateGame(delta);

    // Host also updates ctrl player pos from received commands
    if(players.ctrl && ctrlInput){
      movePlayer(players.ctrl, delta);
    }

    // Fire bullets if pressed and cooldown passed
    fireCooldown -= delta;
    if(pressed.fire && fireCooldown <= 0) {
      fireCooldown = 0.3;
      // spawn bullet from player in facing direction (for simplicity: straight up)
      const p = players[localPlayerId];
      bullets.push({x:p.x,y:p.y-20,vx:0,vy:-400});
    }

    drawGame();
  }

  requestAnimationFrame(gameLoop);
}

let lastFrame = 0;
let ctrlInput = null; // {up,down,left,right,fire}

function handleDataChannelMessage(event){
  try {
    const data = JSON.parse(event.data);
    if(data.type === "input"){
      ctrlInput = data.input;
      Object.assign(pressed, ctrlInput);
    }
  } catch(e){
    log("Invalid data:", e);
  }
}

function setupDataChannelHandlers(dc){
  dc.onopen = () => {
    dcReady = true;
    log("DataChannel open");
    controllerStatus.textContent = "Connected!";
  };
  dc.onclose = () => {
    dcReady = false;
    log("DataChannel closed");
    controllerStatus.textContent = "Disconnected";
  };
  dc.onmessage = handleDataChannelMessage;
}

// --- Host (offer) & Controller (answer) signaling via QR ---
// Flow:
// Host: createOffer → show QR → wait scan answer QR → setRemoteDesc
// Controller: scan offer QR → setRemoteDesc → createAnswer → show answer QR → wait for connection

async function hostStart() {
  qrContainer.hidden = false;
  gameCanvas.style.display = "none";
  controllerUI.style.display = "none";
  instructions.textContent = "Create WebRTC offer and show QR code. Have controller scan this QR code.";

  pc = makePeerConnection();

  dataChannel = pc.createDataChannel("input");
  setupDataChannelHandlers(dataChannel);

  pc.onicecandidate = e => {
    if(e.candidate === null) {
      const offer = pc.localDescription.sdp;
      const b64 = btoa(offer);
      log("Offer SDP generated");
      drawQRCode(b64);
      qrText.textContent = "Controller: Scan this QR code to connect";
      qrScanBtn.hidden = true;
      waitAnswerScan();
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
}

async function waitAnswerScan() {
  qrScanBtn.hidden = false;
  qrScanBtn.textContent = "Scan Answer QR";
  qrScanBtn.onclick = async () => {
    qrScanBtn.disabled = true;
    instructions.textContent = "Point your camera at the controller's answer QR code.";
    await startCamera();
    const answerB64 = await waitForQrCode();
    stopCamera();
    try {
      const answerSdp = atob(answerB64);
      const answerDesc = new RTCSessionDescription({type:"answer", sdp: answerSdp});
      await pc.setRemoteDescription(answerDesc);
      instructions.textContent = "Connection established! Starting game...";
      qrContainer.hidden = true;
      gameCanvas.style.display = "block";
      resetGame();
      gameLoop();
    } catch(e){
      instructions.textContent = "Failed to parse answer SDP. Try again.";
      qrScanBtn.disabled = false;
    }
  };
}

async function controllerStart() {
  qrContainer.hidden = false;
  controllerUI.style.display = "none";
  gameCanvas.style.display = "none";

  instructions.textContent = "Scan the host's offer QR code.";

  await startCamera();

  const offerB64 = await waitForQrCode();
  stopCamera();

  instructions.textContent = "Got offer. Creating answer and showing answer QR code.";

  pc = makePeerConnection();

  pc.ondatachannel = e => {
    dataChannel = e.channel;
    setupDataChannelHandlers(dataChannel);
  };

  const offerSdp = atob(offerB64);
  await pc.setRemoteDescription(new RTCSessionDescription({type:"offer", sdp: offerSdp}));

  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  const answerB64 = btoa(pc.localDescription.sdp);

  drawQRCode(answerB64);
  qrText.textContent = "Host: Scan this QR code to connect";
  qrScanBtn.hidden = true;

  // Wait for connection open
  pc.onicecandidate = e => {
    if(e.candidate === null){
      instructions.textContent = "Connection established! Loading controller UI...";
      qrContainer.hidden = true;
      controllerUI.style.display = "flex";
      controllerStatus.textContent = "Connected!";
    }
  };
}

// Controller input events → send JSON {type:"input", input:{up:true,down:false,...}}
function sendInput(){
  if(dcReady && dataChannel){
    try {
      dataChannel.send(JSON.stringify({type:"input", input:pressed}));
    } catch(e){
      log("Send failed", e);
    }
  }
}

function setupControllerControls(){
  // D-pad buttons
  document.querySelectorAll(".dpad .button").forEach(btn => {
    btn.addEventListener("touchstart", e => {
      e.preventDefault();
      const dir = btn.dataset.dir;
      pressed[dir] = true;
      sendInput();
    });
    btn.addEventListener("touchend", e => {
      e.preventDefault();
      const dir = btn.dataset.dir;
      pressed[dir] = false;
      sendInput();
    });
    btn.addEventListener("mousedown", e => {
      e.preventDefault();
      const dir = btn.dataset.dir;
      pressed[dir] = true;
      sendInput();
    });
    btn.addEventListener("mouseup", e => {
      e.preventDefault();
      const dir = btn.dataset.dir;
      pressed[dir] = false;
      sendInput();
    });
    btn.addEventListener("mouseleave", e => {
      e.preventDefault();
      const dir = btn.dataset.dir;
      pressed[dir] = false;
      sendInput();
    });
  });

  // Fire button
  fireBtn.addEventListener("touchstart", e => {
    e.preventDefault();
    pressed.fire = true;
    sendInput();
  });
  fireBtn.addEventListener("touchend", e => {
    e.preventDefault();
    pressed.fire = false;
    sendInput();
  });
  fireBtn.addEventListener("mousedown", e => {
    e.preventDefault();
    pressed.fire = true;
    sendInput();
  });
  fireBtn.addEventListener("mouseup", e => {
    e.preventDefault();
    pressed.fire = false;
    sendInput();
  });
  fireBtn.addEventListener("mouseleave", e => {
    e.preventDefault();
    pressed.fire = false;
    sendInput();
  });
}

function start() {
  if(isController){
    controllerUI.hidden = false;
    setupControllerControls();
    controllerStart();
  } else {
    qrContainer.hidden = false;
    hostStart();
  }
}

start();

/* ==== Qrcodegen library (minified) ==== */
/*
 * QR Code generator library from Project Nayuki
 * License: MIT
 * Full source and docs: https://github.com/nayuki/QR-Code-generator
 * Minified and adapted below for Byte Mode QR code generation
 */
const qrcodegen=(()=>{"use strict";class a{constructor(a,b){this.version=a,this.size=4*a+17,this.errorCorrectionLevel=b,this.modules=new Array(this.size*this.size),this.isFunction=new Array(this.size*this.size),this.dataCache=null,this.mask=-1;for(let b=0;b<this.modules.length;b++)this.modules[b]=!1;for(let b=0;b<this.isFunction.length;b++)this.isFunction[b]=!1,this.modules[b]=!1;this.drawFunctionPatterns()}getModule(a,b){return this.modules[b*this.size+a]}drawFunctionPatterns(){this.drawFinderPattern(3,3),this.drawFinderPattern(this.size-4,3),this.drawFinderPattern(3,this.size-4),this.drawSeparators(),this.drawTimingPatterns(),this.drawAlignmentPatterns(),this.drawDarkModule(),this.reserveFormatInfo(),this.reserveVersionInfo()}drawFinderPattern(a,b){for(let c=-4;c<=4;c++)for(let d=-4;d<=4;d++){const e=a+c,f=b+d;e>=0&&e<this.size&&f>=0&&f<this.size;this.modules[f*this.size+e]=Math.max(Math.abs(c),Math.abs(d))!==2&&Math.max(Math.abs(c),Math.abs(d))!==3}this.setModule(a-3,b-3,!0),this.setModule(a-3,b+3,!0),this.setModule(a+3,b-3,!0),this.setModule(a+3,b+3,!0);for(let c=-1;c<=1;c++)for(let d=-1;d<=1;d++)this.setModule(a+c,b+d,!0)}drawSeparators(){for(let a=0;a<8;a+

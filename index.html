<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Molez-like Scrolling Cave</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: black; color: white;
    height: 100%; width: 100%;
  }
  canvas {
    display: block;
    background: #111;
    margin: 0 auto;
  }
  #controls {
    position: fixed;
    width: 100%;
    bottom: 0;
    left: 0;
    display: flex;
    justify-content: space-around;
    background: rgba(0,0,0,0.5);
    padding: 10px 0;
    user-select: none;
    touch-action: none;
  }
  button {
    background: #222;
    border: 1px solid #555;
    color: white;
    font-size: 20px;
    padding: 10px 15px;
    border-radius: 5px;
  }
  button.pressed {
    background: #555;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="640" height="480"></canvas>

<div id="controls">
  <button id="leftBtn">â—€</button>
  <button id="upBtn">â–²</button>
  <button id="fireBtn">Fire</button>
  <button id="rightBtn">â–¶</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const BLOCK_SIZE = 12;  // smaller blocks for cave vibe
  const TERRAIN_ROWS = Math.floor(HEIGHT / BLOCK_SIZE);
  const TERRAIN_COLS = 100; // wider terrain for scrolling

  let terrain = [];

  let players = [];
  let bullets = [];

  // Scroll offset in pixels
  let scrollX = 0;

  const controls = { left: false, right: false, up: false, fire: false };

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function generateTerrain() {
    terrain = [];
    for(let r = 0; r < TERRAIN_ROWS; r++) {
      terrain[r] = [];
      for(let c = 0; c < TERRAIN_COLS; c++) {
        // Create cave-like shape with some random noise
        if (r > TERRAIN_ROWS - 5) {
          terrain[r][c] = true; // solid bottom 5 rows
        } else if (r > TERRAIN_ROWS - 10) {
          // random blocks around bottom-middle area
          terrain[r][c] = Math.random() < 0.3;
        } else {
          // empty space upper part
          terrain[r][c] = false;
        }
      }
    }

    // Create some tunnels/caves by clearing random patches
    for(let i = 0; i < 150; i++) {
      let cr = randInt(TERRAIN_ROWS - 15, TERRAIN_ROWS - 5);
      let cc = randInt(0, TERRAIN_COLS - 1);
      terrain[cr][cc] = false;
    }
  }

  function drawTerrain() {
    ctx.fillStyle = '#654321';
    for(let r = 0; r < TERRAIN_ROWS; r++) {
      for(let c = 0; c < TERRAIN_COLS; c++) {
        if(terrain[r][c]) {
          // draw blocks offset by scrollX
          const drawX = c * BLOCK_SIZE - scrollX;
          const drawY = r * BLOCK_SIZE;
          if(drawX + BLOCK_SIZE < 0 || drawX > WIDTH) continue; // skip off screen
          ctx.fillRect(drawX, drawY, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  function collidesWithTerrain(x, y, w, h) {
    const startCol = Math.floor((x + scrollX) / BLOCK_SIZE);
    const endCol = Math.floor((x + scrollX + w) / BLOCK_SIZE);
    const startRow = Math.floor(y / BLOCK_SIZE);
    const endRow = Math.floor((y + h) / BLOCK_SIZE);

    for(let r = startRow; r <= endRow; r++) {
      for(let c = startCol; c <= endCol; c++) {
        if(r < 0 || r >= TERRAIN_ROWS || c < 0 || c >= TERRAIN_COLS) continue;
        if(terrain[r][c]) return true;
      }
    }
    return false;
  }

  class Player {
    constructor(id, x, y, color='cyan', isBot=false) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.w = 12;
      this.h = 18;
      this.color = color;
      this.speedX = 0;
      this.speedY = 0;
      this.onGround = false;
      this.isDead = false;
      this.direction = 1;
      this.fireCooldown = 0;
      this.jumpForce = 7;
      this.speed = 2.5;
      this.isBot = isBot;
    }

    moveLeft() {
      this.speedX = -this.speed;
      this.direction = -1;
    }
    moveRight() {
      this.speedX = this.speed;
      this.direction = 1;
    }
    stopX() {
      this.speedX = 0;
    }
    jump() {
      if(this.onGround){
        this.speedY = -this.jumpForce;
        this.onGround = false;
      }
    }
    fire() {
      if(this.fireCooldown <= 0 && !this.isDead) {
        let bulletX = this.direction === 1 ? this.x + this.w : this.x - 6;
        let bulletY = this.y + this.h / 2 - 3;
        bullets.push(new Bullet(this.id, bulletX, bulletY, this.direction));
        this.fireCooldown = 30;
      }
    }
    update() {
      if(this.isDead) return;

      this.speedY += 0.3; // gravity
      if(this.speedY > 8) this.speedY = 8;

      // horizontal move & collision
      let newX = this.x + this.speedX;
      if(!collidesWithTerrain(newX, this.y, this.w, this.h)) {
        this.x = newX;
      }

      // vertical move & collision
      let newY = this.y + this.speedY;
      if(!collidesWithTerrain(this.x, newY, this.w, this.h)) {
        this.y = newY;
        this.onGround = false;
      } else {
        if(this.speedY > 0) this.onGround = true;
        this.speedY = 0;
      }

      // Clamp inside map horizontally
      if(this.x < 0) this.x = 0;
      if(this.x + this.w > TERRAIN_COLS * BLOCK_SIZE) this.x = TERRAIN_COLS * BLOCK_SIZE - this.w;

      // Clamp vertically to canvas bottom
      if(this.y + this.h > HEIGHT) {
        this.y = HEIGHT - this.h;
        this.onGround = true;
        this.speedY = 0;
      }

      if(this.fireCooldown > 0) this.fireCooldown--;

      if(this.isBot && !this.isDead) this.botAI();
    }

    botAI() {
      if(!this.onGround) return;
      if(Math.random() < 0.02) {
        if(this.speedX === 0) this.moveLeft();
        else this.stopX();
      }
      if(Math.random() < 0.01) this.jump();
      if(Math.random() < 0.02) this.fire();
      if(Math.random() < 0.02) {
        if(this.speedX !== 0) this.stopX();
        else {
          if(Math.random() < 0.5) this.moveLeft();
          else this.moveRight();
        }
      }
    }

    draw() {
      if(this.isDead) {
        ctx.fillStyle = '#900';
        ctx.fillRect(this.x - scrollX, this.y, this.w, this.h);
        ctx.fillStyle = 'white';
        ctx.fillText('ðŸ’€', this.x - scrollX + 2, this.y + 14);
        return;
      }
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x - scrollX, this.y, this.w, this.h);
      // eyes
      ctx.fillStyle = 'white';
      if(this.direction === 1) {
        ctx.fillRect(this.x - scrollX + this.w - 5, this.y + 5, 3, 3);
      } else {
        ctx.fillRect(this.x - scrollX + 2, this.y + 5, 3, 3);
      }
    }
  }

  class Bullet {
    constructor(ownerId, x, y, dir) {
      this.ownerId = ownerId;
      this.x = x;
      this.y = y;
      this.w = 6;
      this.h = 6;
      this.speedX = 6 * dir;
      this.speedY = 0;
      this.gravity = 0.15;
      this.isDead = false;
      this.explodeRadius = 18;
      this.color = '#ff4';
    }
    update() {
      if(this.isDead) return;

      this.speedY += this.gravity;
      this.x += this.speedX;
      this.y += this.speedY;

      if(collidesWithTerrain(this.x, this.y, this.w, this.h)) {
        this.explode();
      }

      players.forEach(p => {
        if(p.id !== this.ownerId && !p.isDead && this.collidesWithPlayer(p)) {
          p.isDead = true;
          this.explode();
        }
      });

      if(this.x < 0 || this.x > TERRAIN_COLS * BLOCK_SIZE || this.y > HEIGHT) this.isDead = true;
    }
    collidesWithPlayer(p) {
      return !(this.x + this.w < p.x || this.x > p.x + p.w || this.y + this.h < p.y || this.y > p.y + p.h);
    }
    explode() {
      this.isDead = true;
      const centerX = this.x + this.w / 2 + scrollX;
      const centerY = this.y + this.h / 2;

      for(let r=0; r<TERRAIN_ROWS; r++) {
        for(let c=0; c<TERRAIN_COLS; c++) {
          let blockX = c * BLOCK_SIZE + BLOCK_SIZE/2;
          let blockY = r * BLOCK_SIZE + BLOCK_SIZE/2;
          const dist = Math.hypot(blockX - centerX, blockY - centerY);
          if(dist < this.explodeRadius) {
            terrain[r][c] = false;
          }
        }
      }
    }
    draw() {
      if(this.isDead) return;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(this.x - scrollX + this.w/2, this.y + this.h/2, this.w/2, this.h/2, 0, 0, 2*Math.PI);
      ctx.fill();
    }
  }

  // Input handling
  function bindButton(button, controlName) {
    button.addEventListener('touchstart', e => {
      e.preventDefault();
      controls[controlName] = true;
      button.classList.add('pressed');
    });
    button.addEventListener('touchend', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
    button.addEventListener('mousedown', e => {
      e.preventDefault();
      controls[controlName] = true;
      button.classList.add('pressed');
    });
    button.addEventListener('mouseup', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
    button.addEventListener('mouseleave', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
  }

  bindButton(document.getElementById('leftBtn'), 'left');
  bindButton(document.getElementById('rightBtn'), 'right');
  bindButton(document.getElementById('upBtn'), 'up');
  bindButton(document.getElementById('fireBtn'), 'fire');

  // Game loop functions
  function updateGame() {
    let localPlayer = players[0];
    if(localPlayer && !localPlayer.isDead) {
      if(controls.left && !controls.right) localPlayer.moveLeft();
      else if(controls.right && !controls.left) localPlayer.moveRight();
      else localPlayer.stopX();
      if(controls.up) localPlayer.jump();
      if(controls.fire) localPlayer.fire();
    }

    players.forEach(p => p.update());
    bullets.forEach(b => b.update());

    bullets = bullets.filter(b => !b.isDead);

    // Update scrollX to follow player horizontally, clamp to terrain edges
    if(localPlayer) {
      // center player horizontally but clamp so we don't scroll past terrain edges
      let targetScroll = localPlayer.x + localPlayer.w/2 - WIDTH/2;
      if(targetScroll < 0) targetScroll = 0;
      if(targetScroll > TERRAIN_COLS * BLOCK_SIZE - WIDTH) targetScroll = TERRAIN_COLS * BLOCK_SIZE - WIDTH;
      scrollX += (targetScroll - scrollX) * 0.1; // smooth easing
    }
  }

  function drawGame() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawTerrain();
    players.forEach(p => p.draw());
    bullets.forEach(b => b.draw());
  }

  function gameLoop() {
    updateGame();
    drawGame();
    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    generateTerrain();

    players = [];
    players.push(new Player('local', 100, HEIGHT - 40, 'cyan'));
    players.push(new Player('bot1', 300, HEIGHT - 40, 'red', true));
    players.push(new Player('bot2', 500, HEIGHT - 40, 'lime', true));

    gameLoop();
  }

  startGame();

  // fullscreen on tap
  document.body.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    }
  });
})();
</script>
</body>
</html>

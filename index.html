<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Molez-like Cave with D-Pad and Responsive Landscape</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: black; color: white; height: 100%; width: 100%;
  }
  #gameCanvas {
    display: block;
    background: #111;
    touch-action: none;
  }
  #controls {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 30px;
    user-select: none;
    touch-action: none;
  }
  #dpad {
    position: relative;
    width: 140px;
    height: 140px;
    background: rgba(20, 20, 20, 0.7);
    border-radius: 10px;
    display: grid;
    grid-template-columns: 50px 40px 50px;
    grid-template-rows: 50px 40px 50px;
    gap: 10px;
  }
  .dpad-btn {
    background: #222;
    border: 2px solid #555;
    border-radius: 10px;
    touch-action: none;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 26px;
    color: white;
    user-select: none;
    transition: background-color 0.15s ease;
  }
  .dpad-btn.pressed {
    background-color: #555;
  }
  #upBtn { grid-area: 1 / 2 / 2 / 3; }
  #leftBtn { grid-area: 2 / 1 / 3 / 2; }
  #downBtn { grid-area: 3 / 2 / 4 / 3; }
  #rightBtn { grid-area: 2 / 3 / 3 / 4; }
  #fireBtn {
    background: #a33;
    border: 2px solid #c55;
    border-radius: 50%;
    width: 80px;
    height: 80px;
    font-size: 24px;
    color: white;
    user-select: none;
    touch-action: none;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.15s ease;
  }
  #fireBtn.pressed {
    background-color: #d66;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="controls">
  <div id="dpad">
    <button id="upBtn" class="dpad-btn">â–²</button>
    <button id="leftBtn" class="dpad-btn">â—€</button>
    <button id="downBtn" class="dpad-btn">â–¼</button>
    <button id="rightBtn" class="dpad-btn">â–¶</button>
  </div>
  <button id="fireBtn">Fire</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  let WIDTH, HEIGHT;

  const BLOCK_SIZE = 12;

  let TERRAIN_ROWS, TERRAIN_COLS;
  let terrain = [];

  let players = [];
  let bullets = [];

  let scrollX = 0;

  const controls = { left: false, right: false, up: false, down: false, fire: false };

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function resize() {
    // Fill entire screen for landscape, swap if portrait (we want landscape full screen)
    if(window.innerWidth > window.innerHeight) {
      WIDTH = window.innerWidth;
      HEIGHT = window.innerHeight;
    } else {
      // force landscape by swapping width/height
      WIDTH = window.innerHeight;
      HEIGHT = window.innerWidth;
    }
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Calculate terrain size to exactly fill canvas with BLOCK_SIZE pixels
    TERRAIN_COLS = Math.floor(WIDTH / BLOCK_SIZE);
    TERRAIN_ROWS = Math.floor(HEIGHT / BLOCK_SIZE);

    generateTerrain();
  }

  function generateTerrain() {
    terrain = [];
    for(let r = 0; r < TERRAIN_ROWS; r++) {
      terrain[r] = [];
      for(let c = 0; c < TERRAIN_COLS; c++) {
        if(r > TERRAIN_ROWS - 6) {
          terrain[r][c] = true; // solid bottom 6 rows
        } else if (r > TERRAIN_ROWS - 12) {
          terrain[r][c] = Math.random() < 0.3;
        } else {
          terrain[r][c] = false;
        }
      }
    }

    // Create some caves/tunnels by clearing some blocks
    for(let i=0; i< Math.floor(TERRAIN_ROWS*TERRAIN_COLS*0.15); i++) {
      let cr = randInt(TERRAIN_ROWS - 15, TERRAIN_ROWS - 6);
      let cc = randInt(0, TERRAIN_COLS - 1);
      terrain[cr][cc] = false;
    }
  }

  function drawTerrain() {
    ctx.fillStyle = '#654321';
    for(let r = 0; r < TERRAIN_ROWS; r++) {
      for(let c = 0; c < TERRAIN_COLS; c++) {
        if(terrain[r][c]) {
          const drawX = c * BLOCK_SIZE - scrollX;
          const drawY = r * BLOCK_SIZE;
          if(drawX + BLOCK_SIZE < 0 || drawX > WIDTH) continue;
          ctx.fillRect(drawX, drawY, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  function collidesWithTerrain(x, y, w, h) {
    const startCol = Math.floor((x + scrollX) / BLOCK_SIZE);
    const endCol = Math.floor((x + scrollX + w) / BLOCK_SIZE);
    const startRow = Math.floor(y / BLOCK_SIZE);
    const endRow = Math.floor((y + h) / BLOCK_SIZE);

    for(let r = startRow; r <= endRow; r++) {
      for(let c = startCol; c <= endCol; c++) {
        if(r < 0 || r >= TERRAIN_ROWS || c < 0 || c >= TERRAIN_COLS) continue;
        if(terrain[r][c]) return true;
      }
    }
    return false;
  }

  class Player {
    constructor(id, x, y, color='cyan', isBot=false) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.w = 12;
      this.h = 18;
      this.color = color;
      this.speedX = 0;
      this.speedY = 0;
      this.onGround = false;
      this.isDead = false;
      this.direction = 1;
      this.fireCooldown = 0;
      this.jumpForce = 7;
      this.speed = 2.5;
      this.isBot = isBot;
    }

    moveLeft() {
      this.speedX = -this.speed;
      this.direction = -1;
    }
    moveRight() {
      this.speedX = this.speed;
      this.direction = 1;
    }
    stopX() {
      this.speedX = 0;
    }
    jump() {
      if(this.onGround){
        this.speedY = -this.jumpForce;
        this.onGround = false;
      }
    }
    moveDown() {
      // Optional future feature: crouch or drop through platforms
    }
    fire() {
      if(this.fireCooldown <= 0 && !this.isDead) {
        let bulletX = this.direction === 1 ? this.x + this.w : this.x - 6;
        let bulletY = this.y + this.h / 2 - 3;
        bullets.push(new Bullet(this.id, bulletX, bulletY, this.direction));
        this.fireCooldown = 30;
      }
    }
    update() {
      if(this.isDead) return;

      this.speedY += 0.3; // gravity
      if(this.speedY > 8) this.speedY = 8;

      // horizontal move & collision
      let newX = this.x + this.speedX;
      if(!collidesWithTerrain(newX, this.y, this.w, this.h)) {
        this.x = newX;
      }

      // vertical move & collision
      let newY = this.y + this.speedY;
      if(!collidesWithTerrain(this.x, newY, this.w, this.h)) {
        this.y = newY;
        this.onGround = false;
      } else {
        if(this.speedY > 0) this.onGround = true;
        this.speedY = 0;
      }

      // Clamp inside map horizontally
      if(this.x < 0) this.x = 0;
      if(this.x + this.w > TERRAIN_COLS * BLOCK_SIZE) this.x = TERRAIN_COLS * BLOCK_SIZE - this.w;

      // Clamp vertically to canvas bottom
      if(this.y + this.h > HEIGHT) {
        this.y = HEIGHT - this.h;
        this.onGround = true;
        this.speedY = 0;
      }

      if(this.fireCooldown > 0) this.fireCooldown--;

      if(this.isBot && !this.isDead) this.botAI();
    }

    botAI() {
      if(!this.onGround) return;
      if(Math.random() < 0.02) {
        if(this.speedX === 0) this.moveLeft();
        else this.stopX();
      }
      if(Math.random() < 0.01) this.jump();
      if(Math.random() < 0.02) this.fire();
      if(Math.random() < 0.02) {
        if(this.speedX !== 0) this.stopX();
        else {
          if(Math.random() < 0.5) this.moveLeft();
          else this.moveRight();
        }
      }
    }

    draw() {
      if(this.isDead) {
        ctx.fillStyle = '#900';
        ctx.fillRect(this.x - scrollX, this.y, this.w, this.h);
        ctx.fillStyle = 'white';
        ctx.fillText('ðŸ’€', this.x - scrollX + 2, this.y + 14);
        return;
      }
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x - scrollX, this.y, this.w, this.h);
      // eyes
      ctx.fillStyle = 'white';
      if(this.direction === 1) {
        ctx.fillRect(this.x - scrollX + this.w - 5, this.y + 5, 3, 3);
      } else {
        ctx.fillRect(this.x - scrollX + 2, this.y + 5, 3, 3);
      }
    }
  }

  class Bullet {
    constructor(ownerId, x, y, dir) {
      this.ownerId = ownerId;
      this.x = x;
      this.y = y;
      this.w = 6;
      this.h = 6;
      this.speedX = 6 * dir;
      this.speedY = 0;
      this.gravity = 0.15;
      this.isDead = false;
      this.explodeRadius = 18;
      this.color = '#ff4';
    }
    update() {
      if(this.isDead) return;

      this.speedY += this.gravity;
      this.x += this.speedX;
      this.y += this.speedY;

      if(collidesWithTerrain(this.x, this.y, this.w, this.h)) {
        this.explode();
      }

      players.forEach(p => {
        if(p.id !== this.ownerId && !p.isDead && this.collidesWithPlayer(p)) {
          p.isDead = true;
          this.explode();
        }
      });

      if(this.x < 0 || this.x > TERRAIN_COLS * BLOCK_SIZE || this.y > HEIGHT) this.isDead = true;
    }
    collidesWithPlayer(p) {
      return !(this.x + this.w < p.x || this.x > p.x + p.w || this.y + this.h < p.y || this.y > p.y + p.h);
    }
    explode() {
      this.isDead = true;
      const centerX = this.x + this.w / 2 + scrollX;
      const centerY = this.y + this.h / 2;

      for(let r=0; r<TERRAIN_ROWS; r++) {
        for(let c=0; c<TERRAIN_COLS; c++) {
          let blockX = c * BLOCK_SIZE + BLOCK_SIZE/2;
          let blockY = r * BLOCK_SIZE + BLOCK_SIZE/2;
          const dist = Math.hypot(blockX - centerX, blockY - centerY);
          if(dist < this.explodeRadius) {
            terrain[r][c] = false;
          }
        }
      }
    }
    draw() {
      if(this.isDead) return;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(this.x - scrollX + this.w/2, this.y + this.h/2, this.w/2, this.h/2, 0, 0, 2*Math.PI);
      ctx.fill();
    }
  }

  // Bind buttons for touch and mouse events
  function bindButton(button, controlName) {
    button.addEventListener('touchstart', e => {
      e.preventDefault();
      controls[controlName] = true;
      button.classList.add('pressed');
    }, {passive:false});
    button.addEventListener('touchend', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    }, {passive:false});
    button.addEventListener('mousedown', e => {
      e.preventDefault();
      controls[controlName] = true;
      button.classList.add('pressed');
    });
    button.addEventListener('mouseup', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
    button.addEventListener('mouseleave', e => {
      e.preventDefault();
      controls[controlName] = false;
      button.classList.remove('pressed');
    });
  }

  bindButton(document.getElementById('leftBtn'), 'left');
  bindButton(document.getElementById('rightBtn'), 'right');
  bindButton(document.getElementById('upBtn'), 'up');
  bindButton(document.getElementById('downBtn'), 'down'); // down currently unused but bound
  bindButton(document.getElementById('fireBtn'), 'fire');

  // Game loop functions
  function updateGame() {
    let localPlayer = players[0];
    if(localPlayer && !localPlayer.isDead) {
      if(controls.left && !controls.right) localPlayer.moveLeft();
      else if(controls.right && !controls.left) localPlayer.moveRight();
      else localPlayer.stopX();
      if(controls.up) localPlayer.jump();
      if(controls.fire) localPlayer.fire();
    }

    players.forEach(p => p.update());
    bullets.forEach(b => b.update());

    bullets = bullets.filter(b => !b.isDead);

    // Update scrollX to follow player horizontally, clamp to terrain edges
    if(localPlayer) {
      let targetScroll = localPlayer.x + localPlayer.w/2 - WIDTH/2;
      if(targetScroll < 0) targetScroll = 0;
      if(targetScroll > TERRAIN_COLS * BLOCK_SIZE - WIDTH) targetScroll = TERRAIN_COLS * BLOCK_SIZE - WIDTH;
      scrollX += (targetScroll - scrollX) * 0.1; // smooth easing
    }
  }

  function drawGame() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawTerrain();
    players.forEach(p => p.draw());
    bullets.forEach(b => b.draw());
  }

  function gameLoop() {
    updateGame();
    drawGame();
    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    resize();
    players = [];
    players.push(new Player('local', 100, HEIGHT - 40, 'cyan'));
    players.push(new Player('bot1', 300, HEIGHT - 40, 'red', true));
    players.push(new Player('bot2', 500, HEIGHT - 40, 'lime', true));
    gameLoop();
  }

  // Resize and handle orientation change
  window.addEventListener('resize', () => {
    resize();
  });

  window.addEventListener('orientationchange', () => {
    resize();
  });

  // Start game after page load
  window.onload = () => {
    startGame();
  };

  // Tap to fullscreen
  document.body.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    }
  });
})();
</script>
</body>
</html>

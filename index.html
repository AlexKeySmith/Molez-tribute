<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>MoleZ with Grapple & Aim</title>
<style>
  * { box-sizing:border-box; margin:0; padding:0; }
  html, body { height:100%; overflow:hidden; }
  body { background:#081221; color:#e5eaf5; font-family:sans-serif; }
  canvas { display:block; width:100%; height:100%; background:#03101c; }
  .hud {
    position:absolute; top:10px; left:10px; right:10px;
    display:flex; justify-content:space-between; z-index:10;
    pointer-events:none; font-size:14px;
  }
  .ctrl-area {
    position:absolute; bottom:10px; left:10px; right:10px;
    display:flex; justify-content:space-between; z-index:10;
    pointer-events:none;
  }
  .dpad, .actions { display:flex; flex-direction:column; gap:6px; pointer-events:auto; }
  .dpad-row { display:flex; gap:6px; justify-content:center; }
  .btn {
    width:48px; height:48px; border-radius:8px;
    background:#14345a; border:1px solid #285180;
    display:flex; align-items:center; justify-content:center;
    color:#e5eaf5; font-size:20px; user-select:none; cursor:pointer;
  }
  .act-btn {
    width:64px; height:50px; background:#355a86; border:1px solid #4e7aa7;
    font-size:14px;
  }
  .btn:active { filter:brightness(1.2); }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="hud">
  <div>
    <span id="timeLabel">Time: 120</span> |
    <span id="scoreLabel">Score: 0</span>
  </div>
  <div>
    <button id="resetBtn" style="pointer-events:auto;padding:4px 10px;">Reset</button>
  </div>
</div>

<div class="ctrl-area">
  <div class="dpad">
    <div class="dpad-row">
      <div></div>
      <div class="btn" id="btnUp">▲</div>
      <div></div>
    </div>
    <div class="dpad-row">
      <div class="btn" id="btnLeft">◀</div>
      <div class="btn" id="btnDown">▼</div>
      <div class="btn" id="btnRight">▶</div>
    </div>
  </div>
  <div class="actions">
    <div class="btn act-btn" id="btnJump">Jump</div>
    <div class="btn act-btn" id="btnFire">Fire</div>
    <div class="btn act-btn" id="btnGrapple">Grapple</div>
  </div>
</div>

<script>
// Basic MoleZ-like engine with aiming and grappling
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

// Terrain grid
const CELL = 4; const COLS = 300; const ROWS = 60;
let terrain = [];

// Game state
let players = [];
let bullets = [];
let ropes = [];
let timeLeft = 120;
let score = 0;
let running = true;

// Player class
class Player {
  constructor(x,y,color) {
    this.x=x; this.y=y; this.vx=0; this.vy=0;
    this.w=12; this.h=12; this.c=color;
    this.onGround=false;
    this.jumpCooldown=0; this.fireCooldown=0; this.grappleCooldown=0;
    this.aim = 0; // radians
    this.rope = null;
  }
  input(input) {
    const speed = 1.5;
    if(input.left) { this.vx = -speed; }
    if(input.right) { this.vx = speed; }
    if(!input.left && !input.right) { this.vx *= 0.85; }
    // tilt gun
    const aimStep = 0.07;
    if(input.up) this.aim -= aimStep;
    if(input.down) this.aim += aimStep;
    // limit aim between -pi/2 and pi/2
    this.aim = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.aim));
    // jump
    if(input.jump && this.onGround && this.jumpCooldown<=0) {
      this.vy = -5; this.onGround=false; this.jumpCooldown=15;
    }
    // fire bullet
    if(input.fire && this.fireCooldown<=0) {
      this.fire(); this.fireCooldown = 20;
    }
    // grapple
    if(input.grapple && this.grappleCooldown<=0) {
      this.toggleGrapple(); this.grappleCooldown = 20;
    }
    this.jumpCooldown=Math.max(0,this.jumpCooldown-1);
    this.fireCooldown=Math.max(0,this.fireCooldown-1);
    this.grappleCooldown=Math.max(0,this.grappleCooldown-1);
  }
  fire() {
    const muzzleX = this.x + this.w/2 + Math.cos(this.aim)*6;
    const muzzleY = this.y + this.h/2 + Math.sin(this.aim)*6;
    const speed = 2.5;
    bullets.push(new Bullet(muzzleX,muzzleY,Math.cos(this.aim)*speed,Math.sin(this.aim)*speed,this));
  }
  toggleGrapple() {
    if(this.rope) {
      this.rope.detach();
    } else {
      const c = this.getCenter();
      const maxLen = 200;
      const step = 4;
      for(let t=0; t<maxLen; t+=step) {
        const tx = c.x + Math.cos(this.aim)*t;
        const ty = c.y + Math.sin(this.aim)*t;
        if(isSolid(tx,ty)) {
          this.rope = new Rope(this, {x:tx,y:ty});
          ropes.push(this.rope);
          break;
        }
      }
    }
  }
  getCenter() { return {x:this.x+this.w/2, y:this.y+this.h/2}; }
  update() {
    // apply gravity
    if(!this.rope) this.vy += 0.25;
    // rope physics
    if(this.rope) this.rope.update();
    // move horizontally
    this.x += this.vx;
    if(isSolid(this.x, this.y) || isSolid(this.x, this.y+this.h)) {
      this.x -= this.vx; this.vx=0;
    }
    // move vertically
    this.y += this.vy;
    if(isSolid(this.x, this.y+this.h) || isSolid(this.x+this.w, this.y+this.h)) {
      // on ground
      while(isSolid(this.x, this.y+this.h) || isSolid(this.x+this.w,this.y+this.h)) {
        this.y -= 1;
      }
      this.vy=0; this.onGround=true;
    } else {
      this.onGround=false;
    }
    // boundaries
    this.x = Math.max(0, Math.min(this.x, COLS*CELL - this.w));
    this.y = Math.max(0, Math.min(this.y, ROWS*CELL - this.h));
  }
  draw() {
    ctx.fillStyle = this.c;
    ctx.fillRect(this.x, this.y, this.w, this.h);
    // draw gun
    const c = this.getCenter();
    ctx.strokeStyle = this.c; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x + Math.cos(this.aim)*15, c.y + Math.sin(this.aim)*15);
    ctx.stroke();
  }
}

// Bullet class
class Bullet {
  constructor(x,y,vx,vy,owner) {
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.r=3; this.owner=owner; this.life=180;
  }
  update() {
    this.vy += 0.15;
    this.x += this.vx;
    this.y += this.vy;
    // collision with terrain
    if(isSolid(this.x,this.y)) {
      carve(this.x,this.y,8);
      this.life=0; return;
    }
    // hit players
    for(const p of players) {
      if(p===this.owner) continue;
      const dx=p.x+p.w/2-this.x, dy=p.y+p.h/2-this.y;
      if(dx*dx + dy*dy < (p.w/2+this.r)*(p.w/2+this.r)) {
        carve(this.x,this.y,12);
        score += 1;
        this.life=0; return;
      }
    }
    this.life--;
  }
  draw() {
    ctx.fillStyle='#ffdf77';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
    ctx.fill();
  }
}

// Rope class
class Rope {
  constructor(player, anchor) {
    this.player=player;
    this.anchor=anchor;
    this.rest = 120;
  }
  update() {
    const c = this.player.getCenter();
    const dx=this.anchor.x-c.x, dy=this.anchor.y-c.y;
    const d = Math.sqrt(dx*dx+dy*dy);
    if(d > this.rest) {
      const stretch = d - this.rest;
      const k=0.02;
      const fx = (dx/d)*stretch*k;
      const fy = (dy/d)*stretch*k;
      this.player.vx += fx;
      this.player.vy += fy;
    }
    // swing left/right controls
    if(input.left) this.player.vx -= 0.05;
    if(input.right) this.player.vx += 0.05;
    // rope snaps if terrain destroyed
    if(!isSolid(this.anchor.x,this.anchor.y)) {
      this.detach();
    }
  }
  detach() {
    this.player.rope = null;
    const idx = ropes.indexOf(this);
    if(idx>=0) ropes.splice(idx,1);
  }
  draw() {
    const c=this.player.getCenter();
    ctx.strokeStyle='#86d7f2'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(this.anchor.x, this.anchor.y);
    ctx.stroke();
  }
}

// Terrain functions
function generateTerrain() {
  const grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const rand = y<ROWS*0.5 ? 0 : (Math.random()<0.5?1:0);
      grid[y][x]=rand;
    }
  }
  for(let i=0;i<3;i++){
    const copy=grid.map(r=>r.slice());
    for(let y=1;y<ROWS-1;y++){
      for(let x=1;x<COLS-1;x++){
        let sum=0;
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            sum += copy[y+dy][x+dx];
          }
        }
        grid[y][x] = sum>=5?1:0;
      }
    }
  }
  for(let y=Math.floor(ROWS*0.8); y<ROWS; y++){
    for(let x=0; x<COLS; x++) grid[y][x]=1;
  }
  return grid;
}
function isSolid(px,py) {
  const cx = Math.floor(px/CELL), cy=Math.floor(py/CELL);
  if(cx<0||cy<0||cx>=COLS||cy>=ROWS) return true;
  return terrain[cy][cx]!==0;
}
function carve(x,y,r) {
  const cx=Math.floor(x/CELL), cy=Math.floor(y/CELL), rr=Math.ceil(r/CELL);
  for(let yy=cy-rr;yy<=cy+rr;yy++){
    for(let xx=cx-rr;xx<=cx+rr;xx++){
      if(xx>=0&&yy>=0&&xx<COLS&&yy<ROWS){
        const dx=xx-cx, dy=yy-cy;
        if(dx*dx+dy*dy <= (r/CELL)*(r/CELL)) terrain[yy][xx]=0;
      }
    }
  }
}

// Input state
const input = {left:false,right:false,up:false,down:false,jump:false,fire:false,grapple:false};
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft'||e.key==='a') input.left=true;
  if(e.key==='ArrowRight'||e.key==='d') input.right=true;
  if(e.key==='ArrowUp'||e.key==='w') input.up=true;
  if(e.key==='ArrowDown'||e.key==='s') input.down=true;
  if(e.key===' ') input.jump=true;
  if(e.key==='f') input.fire=true;
  if(e.key==='g') input.grapple=true;
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft'||e.key==='a') input.left=false;
  if(e.key==='ArrowRight'||e.key==='d') input.right=false;
  if(e.key==='ArrowUp'||e.key==='w') input.up=false;
  if(e.key==='ArrowDown'||e.key==='s') input.down=false;
  if(e.key===' ') input.jump=false;
  if(e.key==='f') input.fire=false;
  if(e.key==='g') input.grapple=false;
});

// Mobile control bindings
function bindTouch(id, key) {
  const el=document.getElementById(id);
  el.addEventListener('touchstart', e=>{e.preventDefault(); input[key]=true;}, {passive:false});
  el.addEventListener('touchend', e=>{e.preventDefault(); input[key]=false;}, {passive:false});
  el.addEventListener('mousedown', e=>{e.preventDefault(); input[key]=true;});
  el.addEventListener('mouseup', e=>{e.preventDefault(); input[key]=false;});
}
bindTouch('btnLeft','left');
bindTouch('btnRight','right');
bindTouch('btnUp','up');
bindTouch('btnDown','down');
bindTouch('btnJump','jump');
bindTouch('btnFire','fire');
bindTouch('btnGrapple','grapple');

document.getElementById('resetBtn').onclick = ()=>startGame();

function startGame() {
  terrain = generateTerrain();
  players = [new Player(30, 200, '#e6c275')];
  bullets = []; ropes=[]; timeLeft = 120; score=0; running=true;
  document.getElementById('timeLabel').textContent = 'Time: ' + timeLeft;
  document.getElementById('scoreLabel').textContent = 'Score: ' + score;
}

function update() {
  if(!running) return;
  timeLeft -= 1/60;
  if(timeLeft <= 0) { running=false; }
  players.forEach(p=>{ p.input(input); p.update(); });
  bullets = bullets.filter(b=>b.life>0);
  bullets.forEach(b=>b.update());
  ropes.forEach(r=>r.update());
  document.getElementById('timeLabel').textContent = 'Time: ' + Math.ceil(timeLeft);
  document.getElementById('scoreLabel').textContent = 'Score: ' + score;
}
function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // offset for following player
  const hero = players[0];
  const offsetX = Math.max(0, Math.min(hero.x - canvas.width/2, COLS*CELL - canvas.width));
  // draw terrain
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(terrain[y][x]) {
        const px=x*CELL-offsetX;
        const py=y*CELL;
        ctx.fillStyle = terrain[y][x]==1? '#3a5370' : '#24435d';
        ctx.fillRect(px,py,CELL,CELL);
      }
    }
  }
  bullets.forEach(b=>b.draw());
  ropes.forEach(r=>r.draw());
  players.forEach(p=>{ p.draw(); });
}
function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}
startGame();
gameLoop();
</script>
</body>
</html>
